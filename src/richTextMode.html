<!-- Style -->
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<style>
  #toolbar {
    padding: 10px;
    background-color: white;
    border-bottom: 1px solid #ccc;
  }

  #editor {
    border: 1px solid #ccc;
    overflow-y: auto;
    height: calc(100vh - 10px);

  }

  /*  overflow: auto;*/
  #editor-container {
    display: flex;
    flex-direction: column;
    border: 1px solid #ccc;
    position: relative;
    overflow: hidden;
  }

  .ql-container {
    border: 1px solid transparent !important;
    overflow-y: visible !important;
  }

  .ql-container.ql-snow {
    border: 1px solid transparent !important;
    overflow-y: visible !important;

  }

  .ql-editor.ql-blank:focus::before {
    content: '';
  }

  /* Set content font-families */
  .ql-font-Helvetica {
    font-family: "Helvetica";
  }

  .ql-font-AppleChancery {
    font-family: "Apple-Chancery";
  }

  .ql-font-Papyrus {
    font-family: "Papyrus";
  }

  .ql-font-Rockwell {
    font-family: "Rockwell";
  }

  .ql-font-Optima {
    font-family: "Optima";
  }

  .ql-font-Georgia {
    font-family: "Georgia";
  }

  .ql-font-TimesNewRoman {
    font-family: "Times-New-Roman";
  }

  .ql-font-AndaleMono {
    font-family: "Andale-Mono";
  }

  .ql-font-CourierNew {
    font-family: "Courier-New";
  }

  .ql-font-Monaco {
    font-family: "Monaco";
  }

  .ql-font-Menlo {
    font-family: "Menlo";
  }

  #fontSelect .ql-picker-options .ql-picker-item.selected {
    color: #06c;
  }

  #sizeSelect .ql-picker-options .ql-picker-item.selected {
    color: #06c;
  }

  #alignSelect .ql-picker-options .ql-picker-item.selected .ql-stroke {
    stroke: #06c;
  }

  #alignSelect .ql-picker-options .ql-picker-item.selected {
    color: #06c;
  }

  .ql-color .ql-picker-options .ql-picker-item.selected {
    border: 2px solid #000;
  }

  .ql-background .ql-picker-options .ql-picker-item.selected {
    border: 2px solid #000;
  }

  .editor-search-highlight {
    position: absolute;
    pointer-events: none;
    z-index: 1;
    transition: all 0.2s ease;
    border-radius: 2px;
  }

  .editor-search-highlight.active {
    background-color: rgba(255, 152, 0, 0.7) !important;
    border: 2px solid #ff9800 !important;
    box-shadow: 0 0 8px rgba(255, 152, 0, 0.5);
  }

  .editor-search-highlight.inactive {
    background-color: rgba(255, 235, 59, 0.5) !important;
  }

  /* .ql-operate-line-container,
  .ql-operate-block,
  .ql-operate-drag-table {
    display: none !important;
    pointer-events: none !important;
  } */
</style>

<!-- Include Quill stylesheet -->
<!--  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet" />-->
<link href="quill.snow.css" rel="stylesheet" />
<link href="quill.min.css" rel="stylesheet" />
<link href="quill-table-better.css" rel="stylesheet" />
<!-- <link href="quill-table.min.css" rel="stylesheet" /> -->
<meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<script src="quill.js"></script>
<script src="jquery-s.1.4.min.js"></script>
<script src="quill-table-better.js"></script>
<script src="ipad-table-fix.js"></script>
<!-- <script src="quill.min.js"></script> -->
<!-- <script src="quill-table.min.js"></script> -->

<!-- Create the toolbar container -->

<!-- Create the editor container -->
<div id="editor-container" class="editor-container">
  <div id="toolbar">
    <span class="ql-formats">
      <select class="ql-font" id="fontSelect">
        <option value="Helvetica">Helvetica</option>
        <option value="TimesNewRoman">Times New Roman</option>
        <option value="AppleChancery">Apple Chancery</option>
        <option value="Papyrus">Papyrus</option>
        <option value="Rockwell">Rockwell</option>
        <option value="Optima">Optima</option>
        <option value="Georgia">Georgia</option>
        <option value="CourierNew">Courier New</option>
        <option value="Monaco">Monaco</option>
        <option value="Menlo">Menlo</option>
        <option value="AndaleMono">Andale Mono</option>
      </select>
    </span>
    <span class="ql-format-seperator"></span>
    <span class="ql-formats">
      <select class="ql-size" id="sizeSelect">
        <option value="10pt">10pts</option>
        <option value="11pt">11pts</option>
        <option value="12pt">12pts</option>
        <option value="14pt">14pts</option>
        <option value="16pt">16pts</option>
        <option value="18pt">18pts</option>
        <option value="20pt">20pts</option>
        <option value="24pt">24pts</option>
        <option value="28pt">28pts</option>
        <option value="36pt" id="fontSize36">36pts</option>
      </select>
      <button id="insert-table">
        <?xml version="1.0"
        encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
        <svg width="auto" height="auto" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg">
          <path
            d="M4 12L20 12M12 4L12 20M6.2 20H17.8C18.9201 20 19.4802 20 19.908 19.782C20.2843 19.5903 20.5903 19.2843 20.782 18.908C21 18.4802 21 17.9201 21 16.8V7.2C21 6.0799 21 5.51984 20.782 5.09202C20.5903 4.71569 20.2843 4.40973 19.908 4.21799C19.4802 4 18.9201 4 17.8 4H6.2C5.0799 4 4.51984 4 4.09202 4.21799C3.71569 4.40973 3.40973 4.71569 3.21799 5.09202C3 5.51984 3 6.07989 3 7.2V16.8C3 17.9201 3 18.4802 3.21799 18.908C3.40973 19.2843 3.71569 19.5903 4.09202 19.782C4.51984 20 5.07989 20 6.2 20Z"
            stroke="#000000" stroke-width="2" stroke-linecap="round"
            stroke-linejoin="round" />
        </svg>
      </button>
    </span>
    <span class="ql-formats">
      <button class="ql-bold"></button>
      <button class="ql-italic"></button>
      <button class="ql-underline"></button>
      <button class="ql-strike"></button>
    </span>
    <span class="ql-format-seperator" style="margin-left:-4px;"></span>
    <span class="ql-formats">
      <select class="ql-color" id="custom-color-picker">
        <option value="#ff0000" style="background-color: #ff0000;">Red</option>
        <option value="#ffff00"
          style="background-color: #ffff00;">Yellow</option>
        <option value="#008000"
          style="background-color: #008000;">Green</option>
        <option value="#0000ff" style="background-color: #0000ff;">Blue</option>
        <option value="#ffa500"
          style="background-color: #ffa500;">Orange</option>
        <option value="#800080"
          style="background-color: #800080;">Purple</option>
        <option value="#a52a2a"
          style="background-color: #a52a2a;">Brown</option>
        <option value="#000000"
          style="background-color: #000000;">Black</option>
        <option value="#808080" style="background-color: #808080;">Gray</option>
        <option value="#a9a9a9" style="background-color: #a9a9a9;">Light
          Gray</option>
        <option value="#ffffff"
          style="background-color: #ffffff;">White</option>
        <option value="#1e97f3" style="background-color: #1e97f3;">Light
          Blue</option>
        <option value="#1fd655" style="background-color: #1fd655;">Light
          Green</option>
        <option value="#ff8da1" style="background-color: #ff8da1;">Pink</option>
        <option value="#ff8b3d" style="background-color: #ff8b3d;">Light
          Orange</option>
      </select>
      <select class="ql-background" id="custom-background-picker">
        <option value="#ff0000" style="background-color: #ff0000;">Red</option>
        <option value="#ffff00"
          style="background-color: #ffff00;">Yellow</option>
        <option value="#008000"
          style="background-color: #008000;">Green</option>
        <option value="#0000ff" style="background-color: #0000ff;">Blue</option>
        <option value="#ffa500"
          style="background-color: #ffa500;">Orange</option>
        <option value="#800080"
          style="background-color: #800080;">Purple</option>
        <option value="#a52a2a"
          style="background-color: #a52a2a;">Brown</option>
        <option value="#000000"
          style="background-color: #000000;">Black</option>
        <option value="#808080" style="background-color: #808080;">Gray</option>
        <option value="#a9a9a9" style="background-color: #a9a9a9;">Light
          Gray</option>
        <option value="#ffffff"
          style="background-color: #ffffff;">White</option>
        <option value="#1e97f3" style="background-color: #1e97f3;">Light
          Blue</option>
        <option value="#1fd655" style="background-color: #1fd655;">Light
          Green</option>
        <option value="#ff8da1" style="background-color: #ff8da1;">Pink</option>
        <option value="#ff8b3d" style="background-color: #ff8b3d;">Light
          Orange</option>
      </select>
    </span>
    <span class="ql-format-seperator"></span>
    <span class="ql-formats">
      <button class="ql-list" value="ordered"></button>
      <button class="ql-list" value="bullet"></button>
      <select class="ql-align" id="alignSelect">
        <option label="left" class="selected"></option>
        <option label="center" value="center"></option>
        <option label="right" value="right"></option>
        <option label="justify" value="justify"></option>
      </select>
       <!-- Your existing toolbar buttons -->
      <button class="ql-find-replace" title="Find and Replace">
        <svg viewBox="0 0 18 18">
          <path d="M7 0a7 7 0 1 0 4.95 11.95l4.55 4.55 1.5-1.5-4.55-4.55A7 7 0 0 0 7 0zm0 2a5 5 0 1 1 0 10A5 5 0 0 1 7 2z"/>
        </svg>
      </button>
    </span>
  </div>
  <div id="editor">
    <p><span id="firstElement" class><span></p>
  </div>
</div>

<script>
  var placeHolderLanguage = 'Enter note content here';
  var keyboardHeight = 0;
  var isTabToEdit = null;
  var isPlanNote = false;
  var isKeyboardOperation = false;
  var belowContentHeight = 0;
  let defaultFormats = {
    "font": "",
    "size": ""
};
  // Expose userDeselectedFormats globally so quill-table-better.ts can access it
  window.userDeselectedFormats = {};
  const userDeselectedFormats = window.userDeselectedFormats;
  // Track if we're currently in a table cell
 let isInTableCell = false;


  let lastFormats = {};
  let deviceType = '';
  let cursorIndex;
  // Add fonts to whitelist
  let Font = Quill.import('formats/font');
  // We do not add Sans Serif since it is the default
  Font.whitelist = [
    "TimesNewRoman",
    "Helvetica",
    "AppleChancery",
    "Papyrus",
    "Rockwell",
    "Optima",
    "Georgia",
    "AndaleMono",
    "CourierNew",
    "Monaco",
    "Menlo"
];
  Quill.register(Font, true);

  var Size = Quill.import('attributors/style/size');
  Size.whitelist = [
    "10pt",
    "11pt",
    "12pt",
    "14pt",
    "16pt",
    "18pt",
    "20pt",
    "24pt",
    "28pt",
    "36pt"
];
  Quill.register(Size, true);
  Quill.register({
  'modules/table-better': QuillTableBetter
}, true);

// Create a custom Quill module for find and replace
class FindAndReplace {
  constructor(quill, options) {
    this.quill = quill;
    this.options = options;
    this.currentIndex = -1;
    this.matches = [];
    this.highlightElements = [];
    this.isPanelOpen = false; // Add this flag
    window.isSearchInProgress = false;
    
    // Create UI panel
    this.createUI();
    
    // Add keyboard shortcuts
    this.addKeyboardShortcuts();
  }
  
  createUI() {
    const container = this.quill.container.parentNode;

    // Create find/replace panel
    const panel = document.createElement('div');
    panel.id = 'find-replace-panel';
      // Detect device type
    const isIPad = /iPad/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isIPhone = /iPhone/.test(navigator.userAgent);
    const isTablet = isIPad || (window.innerWidth >= 768 && window.innerWidth <= 1024);
    
    // Apply device-specific styling
    if (isTablet && !isIPhone) {
         // iPad/Tablet layout - compact single line, positioned below toolbar
      panel.style.cssText = `
        display: none;
        position: fixed;
        top: 5px;
        left: 10px;
        right: 10px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 6px 8px 4px 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 10000;
        max-width: calc(100vw - 20px);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      `;
      
      panel.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
          <!-- Find Input -->
          <input type="text" id="find-input" placeholder="Find..." 
                style="flex: 1 1 140px; min-width: 120px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; outline: none;">
          
          <!-- Replace Input -->
          <input type="text" id="replace-input" placeholder="Replace..." 
                style="flex: 1 1 140px; min-width: 120px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; outline: none;">
          
          <!-- Navigation Buttons -->
          <button id="find-prev-btn" title="Previous" style="padding: 6px 8px; border: 1px solid #007bff; border-radius: 4px; background: #007bff; color: white; cursor: pointer; display: flex; align-items: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
          </button>
          
          <button id="find-next-btn" title="Next" style="padding: 6px 8px; border: 1px solid #007bff; border-radius: 4px; background: #007bff; color: white; cursor: pointer; display: flex; align-items: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
          
          <!-- Replace Buttons -->
          <button id="replace-btn" title="Replace" style="padding: 6px 8px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; display: flex; align-items: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
              <path d="M21 3v5h-5"></path>
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
              <path d="M3 21v-5h5"></path>
            </svg>
          </button>
          
          <button id="replace-all-btn" title="Replace All" style="padding: 6px 10px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; font-size: 11px; font-weight: 600;">All</button>
          
          <!-- Close Button -->
          <button id="close-find-btn" title="Close" style="padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; display: flex; align-items: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div id="match-counter" style="font-size: 11px; color: #666; text-align: center; padding: 2px; margin-top: 2px;"></div>
      `;
    } else {
         // iPhone/Mobile layout - positioned below toolbar, full width
      panel.style.cssText = `
        display: none;
        position: fixed;
        top: 5px;
        left: 5px;
        right: 5px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 6px 8px 4px 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 10000;
        max-width: calc(100vw - 10px);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      `;
      panel.innerHTML = `
        <div style="display: flex; align-items: center; gap: 3px; margin-bottom: 3px;">
          <input type="text" id="find-input" placeholder="Find..." 
                style="flex: 1; padding: 5px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; outline: none;">
          <button id="find-prev-btn" title="Previous" style="padding: 5px 7px; border: 1px solid #007bff; border-radius: 4px; background: #007bff; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
          </button>
          <button id="find-next-btn" title="Next" style="padding: 5px 7px; border: 1px solid #007bff; border-radius: 4px; background: #007bff; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
          <button id="close-find-btn" title="Close" style="padding: 5px 7px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; cursor: pointer; display: flex; align-items: center; justify-content: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div style="display: flex; align-items: center; gap: 3px;">
          <input type="text" id="replace-input" placeholder="Replace..." 
                style="flex: 1; padding: 5px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; outline: none;">
          <button id="replace-btn" title="Replace" style="padding: 5px 7px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
              <path d="M21 3v5h-5"></path>
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
              <path d="M3 21v-5h5"></path>
            </svg>
          </button>
          <button id="replace-all-btn" title="Replace All" style="padding: 5px 10px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; font-size: 11px; font-weight: 600;">All</button>
        </div>
        <div id="match-counter" style="font-size: 10px; color: #666; text-align: center; padding: 2px;"></div>
      `;
    }

    document.body.appendChild(panel);
    this.panel = panel;

    // Attach event listeners
    this.attachEventListeners();

    // Add this in the constructor or initialization
    this.panel.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    this.panel.addEventListener('touchstart', (e) => {
      e.stopPropagation();
    });

    this.panel.addEventListener('touchend', (e) => {
      e.stopPropagation();
    });
  }

  attachEventListeners() {
    const findInput = document.getElementById('find-input');
    const replaceInput = document.getElementById('replace-input');

    document.getElementById('find-next-btn').addEventListener('click', () => {
      this.findNext();
      // Blur the input to close the keyboard
      document.getElementById('find-input').blur();
    });

    document.getElementById('find-prev-btn').addEventListener('click', () => {
      this.findPrevious();
      // Blur the input to close the keyboard
      document.getElementById('find-input').blur();
    });
    document.getElementById('replace-btn').addEventListener('click', () => this.replace());
    document.getElementById('replace-all-btn').addEventListener('click', () => this.replaceAll());
    document.getElementById('close-find-btn').addEventListener('click', () => this.close());

    // Use debounced search to avoid interfering with typing
    let searchTimeout;
    findInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        this.search(e.target.value);
      }, 300);
    });

    // Prevent Quill from capturing focus when typing in inputs
    findInput.addEventListener('keydown', (e) => {
      e.stopPropagation();
    });

    // In the setupEventListeners method, add focus event handler
    findInput.addEventListener('focus', (e) => {
      e.stopPropagation();
    });

    replaceInput.addEventListener('keydown', (e) => {
      e.stopPropagation();
    });

    // Enter key in find input triggers search
    findInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.findNext();
      }
    });
  }
  
  addKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ctrl+F or Cmd+F to open
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        this.open();
      }
      // Escape to close
      if (e.key === 'Escape' && this.panel.style.display === 'block') {
        this.close();
      }
    });
  }
  
  open() {
    this.panel.style.display = 'block';
    this.isPanelOpen = true;
    window.isSearchPanelOpen = true; // Global flag

    const findInput = document.getElementById('find-input');
    findInput.value = '';

    // Use multiple attempts to ensure focus
    findInput.focus();

    // Force focus after a short delay to override any other focus attempts
    setTimeout(() => {
      findInput.focus();
    }, 50);

    setTimeout(() => {
      findInput.focus();
    }, 150);

    this.clearHighlights();
  }
  
  close() {
    this.panel.style.display = 'none';
    this.isPanelOpen = false;
    window.isSearchPanelOpen = false;
    this.clearHighlights();
    document.getElementById('find-input').value = '';
    document.getElementById('replace-input').value = '';
    document.getElementById('match-counter').textContent = '';
  }
  
  // Update search method to NOT focus editor
  search(searchTerm) {
    this.clearHighlights();
    this.matches = [];
    this.currentIndex = -1;

    if (!searchTerm) {
      document.getElementById('match-counter').textContent = '';
      return;
    }

    const text = this.quill.getText();
    const regex = new RegExp(searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
    let match;

    while ((match = regex.exec(text)) !== null) {
      this.matches.push({
        index: match.index,
        length: searchTerm.length
      });
    }

    if (this.matches.length > 0) {
      this.currentIndex = 0;
      this.highlightMatches(false); // Don't focus editor while typing
      this.updateCounter();
    } else {
      document.getElementById('match-counter').textContent = 'No matches found';
    }
  }

  // Modify the highlightMatches function to accept a parameter
  highlightMatches(shouldFocusEditor = false) {
    // Store the currently focused element
    const previouslyFocused = document.activeElement;
    const wasFindInputFocused = previouslyFocused && previouslyFocused.id === 'find-input';

    // Set global flag to prevent selection-change handlers from interfering
    window.isSearchInProgress = true;

    // Clear previous highlights
    this.clearHighlights();

    // Apply background color to all matches
    this.matches.forEach((match, idx) => {
      const isActive = idx === this.currentIndex;

      // Apply background color using Quill's format
      this.quill.formatText(
        match.index,
        match.length,
        'background',
        isActive ? '#FFC107' : '#FFEB3B',
        'silent'
      );

      // Store match info for clearing later
      this.highlightElements.push({
        index: match.index,
        length: match.length
      });
    });

    console.log(`Total highlights applied: ${this.highlightElements.length}`);

    // Only scroll and set selection when explicitly requested (e.g., clicking Find button)
    if (shouldFocusEditor && this.matches[this.currentIndex]) {
      // Scroll to the active match
      const match = this.matches[this.currentIndex];
      const bounds = this.quill.getBounds(match.index, match.length);

      // Calculate scroll position to center the match in viewport
      const editorContainer = this.quill.root.parentElement;
      const containerHeight = editorContainer.clientHeight;
      const scrollTop = bounds.top + editorContainer.scrollTop - (containerHeight / 2) + (bounds.height / 2);

      // Smooth scroll to the match
      editorContainer.scrollTo({
        top: Math.max(0, scrollTop),
        behavior: 'smooth'
      });

      // Set selection on the match
      this.quill.setSelection(match.index, match.length);

      // Reset flag after selection is set
      setTimeout(() => {
        window.isSearchInProgress = false;
      }, 100);
    } else {
      // Reset flag immediately if not focusing editor
      window.isSearchInProgress = false;

      if (wasFindInputFocused) {
        // Restore focus to the find input if it was focused before
        setTimeout(() => {
          const findInput = document.getElementById('find-input');
          if (findInput) {
            findInput.focus();
          }
        }, 0);
      }
    }
  }
  
  clearHighlights() {
    // Remove background color from all highlighted text
    this.highlightElements.forEach(match => {
      if (match.index !== undefined && match.length !== undefined) {
        this.quill.formatText(match.index, match.length, 'background', false, 'silent');
      }
    });
    this.highlightElements = [];
  }
  
  // Update findNext to focus editor
  findNext() {
    if (this.matches.length === 0) return;

    this.currentIndex = (this.currentIndex + 1) % this.matches.length;
    this.highlightMatches(true); // Focus editor when navigating
    this.updateCounter();
  }

  // Update findPrevious to focus editor
  findPrevious() {
    if (this.matches.length === 0) return;

    this.currentIndex = this.currentIndex - 1;
    if (this.currentIndex < 0) {
      this.currentIndex = this.matches.length - 1;
    }
    this.highlightMatches(true); // Focus editor when navigating
    this.updateCounter();
  }
  
  replace() {
    if (this.currentIndex === -1 || this.matches.length === 0) return;

    const match = this.matches[this.currentIndex];
    const replaceText = document.getElementById('replace-input').value;

    // Store current formats at the position
    const formats = this.quill.getFormat(match.index, match.length);

    // Delete and insert with preserved formatting
    this.quill.deleteText(match.index, match.length);
    this.quill.insertText(match.index, replaceText, formats);

    // Re-search after replacement
    //const searchTerm = document.getElementById('find-input').value;
    //setTimeout(() => this.search(searchTerm), 100);

    this.clearHighlights();
    this.matches = [];
    this.currentIndex = -1;
    document.getElementById('match-counter').textContent = '';
  }
  
  replaceAll() {
    if (this.matches.length === 0) return;

    const replaceText = document.getElementById('replace-input').value;
    const searchTerm = document.getElementById('find-input').value;

    // Replace from end to start to maintain indices
    for (let i = this.matches.length - 1; i >= 0; i--) {
      const match = this.matches[i];
      const formats = this.quill.getFormat(match.index, match.length);
      this.quill.deleteText(match.index, match.length);
      this.quill.insertText(match.index, replaceText, formats);
    }

    this.clearHighlights();
    this.matches = [];
    this.currentIndex = -1;
    document.getElementById('match-counter').textContent = '';
    //setTimeout(() => this.search(searchTerm), 100);
  }
  
  updateCounter() {
    if (this.matches.length > 0) {
      document.getElementById('match-counter').textContent =
        `${this.currentIndex + 1} of ${this.matches.length}`;
    }
  }
}

// Global flag to track search panel state
window.isSearchPanelOpen = false;

// Override Quill's focus method when search panel is open
const originalQuillFocus = Quill.prototype.focus;
Quill.prototype.focus = function() {
  if (window.isSearchPanelOpen) {
    console.log('Prevented Quill focus - search panel is open');
    return;
  }
  return originalQuillFocus.call(this);
};

// Register the module
Quill.register('modules/findAndReplace', FindAndReplace);

  var snow = new Quill('#editor', {
    theme: 'snow',
    placeholder: `${placeHolderLanguage}`,
    modules: {
        table: false,
              'table-better': {
                toolbarTable: true,
                menus: ['column', 'row', 'table',  'wrap', 'delete'],
               },
              toolbar: '#toolbar',
              findAndReplace: true
    },
    keyboard: {
          bindings: QuillTableBetter.keyboardBindings
    }
  });



  const table = snow.getModule('table-better');
  const editorContainer = document.getElementById('editor-container');
  const editor = document.getElementById('editor');

  document
    .querySelector('#insert-table').addEventListener('click', function () {
      setTimeout(() => {
      const focusContainer = document.querySelector('.ql-editor');
        if (focusContainer) focusContainer.focus();
        // Center cursor after picker selection
        const selection = snow.getSelection();
        if (selection) {
         scrollToCursorPosition({ index: selection.index }, { centerCursor: true, forceScroll: true });
        }
      }, 100); // A brief timeout seems necessary to let picker close first
      table.insertTable(2, 2);
      setTimeout(() => {
        const tables = document.querySelectorAll('.ql-editor table');
        if (tables.length) {
          const lastTable = tables[tables.length - 1];
          if (lastTable) {
            const cells = lastTable.querySelectorAll('td');
            // Get the first cell's blot for cursor positioning
            const firstCellBlot = Quill.find(cells[0]);
            const firstCellIndex = firstCellBlot ? snow.getIndex(firstCellBlot) : null;
            // Apply formats to all cells
            cells.forEach((cell, index) => {
              applyFormatOnEmptyCell(cell, index === 0);
            });

            // Set cursor to first cell
            if (firstCellIndex !== null) {
              snow.setSelection(firstCellIndex, 0);
            }
          }
        }
      }, 50);
    });

  // Called each time when text changes in the editor
  const toolbar = document.getElementById('toolbar');
  const toolbarWrapper = document.getElementById('toolbarWrapper');

  let editorHeight = document.getElementById('editor').offsetHeight;

  let lastSelectedFormats = {};  // Store the last selected formats globally
  let savedRange = null;
  let lastKnownRange = null; // Always track the latest selection

  let previousSelectedFormat = {};

  const selection = () => {
    if (window.getSelection) return window.getSelection();
  };

  //color and background picker element
  const colorPicker = document.getElementById("custom-color-picker");
  const backgroundPicker = document.getElementById("custom-background-picker");

  //label element
  const bgColorPicker = document.querySelector('.ql-background .ql-picker-label');
  const textColorPicker = document.querySelector('.ql-color .ql-picker-label');

  //label's inner element
  const colorLabel = textColorPicker?.querySelector('line.ql-stroke');
  const backgroundLabel = bgColorPicker?.querySelector('g.ql-fill');

  let lastFormat = {}; // Store the last format applied
  let currentFormat = {};
  snow.on('selection-change', function (range) {
    // applyStylesToListElements(snow);
    // Get the current format at the selection index
    if (range) {
      const currentFormats = snow.getFormat(range);
      lastSelectedFormats = currentFormats || {};
      lastKnownRange = range;
      const format = snow.getFormat(range.index);
      lastFormat = format;
      window.lastUsedFormat = format;
      updateToolbarUI(format);

      const formats = snow.getFormat(range.index, range.length);
      if (Object.keys(formats).length > 0) {
        lastUsedFormats = { ...formats };
      }
    }
    else {
      document.activeElement.blur();
    }
  });


 snow.on('text-change', function (delta, source) {
    // Use the new function for Enter key processing
    // formatEmptyLinesAfterEnter(delta, snow, lastSelectedFormats);
    sendContentToNativeApp();
    //applyStylesToListElements(snow);
    // Get the current format at the selection index
    const currentFormats = snow.getFormat();
      // Get the toolbar module to access userDeselectedFormats
    const toolbar = snow.getModule('toolbar');
  
    // Update lastSelectedFormats but respect user deselections
    if (toolbar && toolbar.userDeselectedFormats) {
      const updatedFormats = { ...lastSelectedFormats };
      
      // Only update formats that haven't been explicitly deselected
      Object.keys(currentFormats).forEach(key => {
        if (!toolbar.userDeselectedFormats[key]) {
          updatedFormats[key] = currentFormats[key];
        }
      });
      
      // Update lastSelectedFormats with our filtered formats
      lastSelectedFormats = updatedFormats;
    } else {
      // Fallback if toolbar module isn't available
      lastSelectedFormats = { ...lastSelectedFormats, ...currentFormats };
    }


    const range = snow.getSelection();
    if (range) {
      const formats = snow.getFormat(range.index);
      // If user is typing in a new empty block, reapply last format
      // if (Object.keys(format).length === 0 && Object.keys(lastFormat).length > 0) {
      //   snow.formatText(range.index, 1, lastFormat);
      // }
      updateToolbarUI(lastSelectedFormats);

      // Update button states based on selection format
      // const boldBtn = document.querySelector('.ql-bold');
      // if (boldBtn) boldBtn.classList.toggle('ql-active', formats.bold === true);

      // const italicBtn = document.querySelector('.ql-italic');
      // if (italicBtn) italicBtn.classList.toggle('ql-active', formats.italic === true);

      // const underlineBtn = document.querySelector('.ql-underline');
      // if (underlineBtn) underlineBtn.classList.toggle('ql-active', formats.underline === true);

      // const strikeBtn = document.querySelector('.ql-strike');
      // if (strikeBtn) strikeBtn.classList.toggle('ql-active', formats.strike === true);
    }
  });



  snow.root.addEventListener('click', function (event) {
    const selection = snow.getSelection();
    if (!selection) return;
    setTimeout(() => {
      handleEmptyLineClick(snow, selection.index);
    }, 20);
  });
    
    // Add touchend event which is more reliable on iOS
    snow.root.addEventListener('touchend', function (event) {
      // Prevent default to avoid any iOS quirks
      //  event.preventDefault();
      
      // Small delay to ensure selection is updated
      setTimeout(() => {
        const selection = snow.getSelection();
        console.log("touchend selection", selection);
        if (!selection) return;
        handleEmptyLineClick(snow, selection.index);
      }, 20); // Slightly longer timeout for iOS
    });

  function getQuillHtml() { return snow.root.innerHTML; }

  function sendContentToNativeApp() {
    try {
      let html = getQuillHtml();
      // Remove empty lines at the end of the document
      //     html = removeTrailingEmptyLines(html);
      // Replace <p><br></p> with &nbsp
      html = html.replace(/<br\s*\/?>/g, '&nbsp;');

      window.webkit.messageHandlers.callbackHandler.postMessage(html);
    } catch (err) {
      console.log('The native context does not exist yet');
    }
  }

  snow.root.addEventListener('mousedown', function (event) {
    let range = snow.getSelection();
    if (!range) return;

    let [line, offset] = snow.getLine(range.index);

    // Ensure clicking at the start allows cursor placement at index 0
    if (line && line.statics.blotName === 'list' && offset === 0) {
      setTimeout(() => {
        snow.setSelection(range.index, 0);
      }, 0);
    }
  });



  document.addEventListener('scroll', (event) => {
    window.scrollTo(0, 0);
  });

  document.querySelectorAll('.ql-picker-item').forEach((item) => {
    if (!item[0]?.hasAttribute('data-value')) {
      item[0]?.setAttribute('data-value', '#000000'); // Assign black color value
    }
    if (!item.hasAttribute('data-value')) {
      item.setAttribute('data-value', '#fffff'); // Assign black color value
    }
  });



  // Updated function to update toolbar UI based on active formats
  function updateToolbarUI(formats) {
    console.log('Updating toolbar UI with formats:', formats);
    // Get the toolbar module to access userDeselectedFormats
    const toolbar = snow.getModule('toolbar');
    const userDeselectedFormats = toolbar?.userDeselectedFormats || {};

    // Update button states for basic formats (bold, italic, underline, strike)
    const formatButtons = {
      bold: document.querySelector('.ql-bold'),
      italic: document.querySelector('.ql-italic'),
      underline: document.querySelector('.ql-underline'),
      strike: document.querySelector('.ql-strike')
    };

    // Update basic format buttons
    Object.keys(formatButtons).forEach(format => {
      if (formatButtons[format]) {
        // For boolean formats like bold, check if the format is true
        if (formats[format] === true && !userDeselectedFormats[format]) {
          formatButtons[format].classList.add('ql-active');
          console.log(`Adding ql-active to ${format} button`);
        } else {
          formatButtons[format].classList.remove('ql-active');
          console.log(`Removing ql-active from ${format} button`);
        }
      }
    });

    // Update color pickers if needed
    if (formats.color && colorLabel) {
         colorLabel.style.stroke = formats.color;
         textColorPicker.classList.add('ql-active');
         // Get all color picker items
         let colorItems = document.querySelectorAll(".ql-color .ql-picker-item");
         colorItems.forEach(item => {
             item.classList.remove("selected");
             item.classList.remove("ql-selected");
           let itemColor = item.getAttribute("data-value"); // Get item color
           // If the item's color matches the selected color, apply the selected class
           if (itemColor == formats.color) {
             item.classList.add("selected");
           }
         });
       }else{
           let colorItems = document.querySelectorAll(".ql-color .ql-picker-item");
           colorItems.forEach(item => {
               item.classList.remove("selected");
           });
       }

     if (formats.background && backgroundLabel) {
         backgroundLabel.style.fill = formats.background;
         bgColorPicker.classList.add('ql-active');
         // Get all color picker items
         let bgItems = document.querySelectorAll(".ql-background .ql-picker-item");
         bgItems.forEach(item => {
             item.classList.remove("selected");
             item.classList.remove("ql-selected");
           let itemColor = item.getAttribute("data-value"); // Get item color
           // If the item's color matches the selected color, apply the selected class
           if (itemColor == formats.background) {
             item.classList.add("selected");
           }
         });
       }else{
           let bgItems = document.querySelectorAll(".ql-background .ql-picker-item");
           bgItems.forEach(item => {
               item.classList.remove("selected");
           });
       }

    // Update font picker
    if (formats.font) {
      const fontValue = document.querySelector('.ql-font .ql-picker-label');
      if (fontValue) {
        fontValue.setAttribute('data-value', formats.font);
        fontValue.setAttribute('aria-label', formats.font);
        fontValue.classList.add('ql-active');
      }
    }

    // Update size picker
    if (formats.size) {

      const sizeValue = document.querySelector('.ql-size .ql-picker-label');
      if (sizeValue) {
        sizeValue.setAttribute('data-value', `${formats.size}`);
        sizeValue.setAttribute('aria-label', `${formats.size}s`);
        sizeValue.classList.add('ql-active');
      }
    }

    // Update alignment buttons
    if (formats.align) {
      const alignButtons = document.querySelectorAll('.ql-align');
      alignButtons.forEach(button => {
        button.classList.remove('ql-active');
      });

      const activeAlignButton = document.querySelector(`.ql-align[value="${formats.align}"]`);
      if (activeAlignButton) {
        activeAlignButton.classList.add('ql-active');
      }
    }
  }

  // Enhanced mobile font & size picker handling
  // This prevents context menu interference on iOS/iPadOS
  (function setupMobilePickerHandlers() {
    // Store active state
    window.activePickerTouch = false;
    // Get references to font and size pickers
    const fontPicker = document.querySelector('.ql-font');
    const sizePicker = document.querySelector('.ql-size');
    const fontPickerLabel = document.querySelector('.ql-font .ql-picker-label');
    const sizePickerLabel = document.querySelector('.ql-size .ql-picker-label');
    // Handle font family selection properly
    function handleFontSelection(event) {
      // Find the selected item
      const selectedFontItem = event.target.closest('.ql-picker-item');
      if (!selectedFontItem) return;
      // Prevent default behavior to avoid context menu
      event.preventDefault();
      event.stopPropagation();
      // Get the selected font value
      const selectedFont = selectedFontItem.getAttribute('data-value');
      if (!selectedFont) return;
      // Get current selection
      const range = snow.getSelection();
      if (!range) return;
      // Store selection details
      const index = range.index;
      const length = range.length;
      // Get current formats to preserve them
      const formats = snow.getFormat(range.index, Math.max(1, range.length));
      // Apply formatting
      if (length > 0) {
        snow.formatText(index, length, {
          ...formats,
          font: selectedFont
        }, 'api');
      } else {
        snow.format('font', selectedFont, 'api');
      }
      // Update UI
      document.querySelectorAll(".ql-picker-item").forEach(item => {
        item.classList.remove("ql-selected");
      });
      selectedFontItem.classList.add("ql-selected");
      fontPickerLabel.classList.add("ql-active");
      fontPicker.classList.remove("ql-expanded");
      // **Fix: Temporarily blur and refocus the editor**
      snow.blur(); // Blur first
      snow.focus(); // Refocus after ensuring blur has applied
      snow.setSelection(index, length); // Restore selection
    }
    // Handle font family selection properly
    function handleSizeSelection(event) {
      // Find the selected item
      const selectedSizeItem = event.target.closest('.ql-picker-item');
      if (!selectedSizeItem) return;
      // Prevent default behavior to avoid context menu
      event.preventDefault();
      event.stopPropagation();
      // Get the selected font value
      const selectedSize = selectedSizeItem.getAttribute('data-value');
      if (!selectedSize) return;
      // Get current selection
      const range = snow.getSelection();
      if (!range) return;
      // Store selection details
      const index = range.index;
      const length = range.length;
      // Get current formats to preserve them
      const formats = snow.getFormat(range.index, Math.max(1, range.length));
      // Apply formatting
      if (length > 0) {
        snow.formatText(index, length, {
          ...formats,
          size: selectedSize
        }, 'api');
      } else {
        snow.format('size', selectedSize, 'api');
      }
      // Update UI
      document.querySelectorAll(".ql-picker-item").forEach(item => {
        item.classList.remove("ql-selected");
      });
      selectedSizeItem.classList.add("ql-selected");
      sizePickerLabel.classList.add("ql-active");
      sizePicker.classList.remove("ql-expanded");
      // **Fix: Temporarily blur and refocus the editor**
      snow.blur(); // Blur first
      snow.focus(); // Refocus after ensuring blur has applied
      snow.setSelection(index, length); // Restore selection
      // Update toolbar to reflect changes
      updateToolbarUI(snow.getFormat(index, length));
    }
    // Set up event listeners for font picker
    if (fontPicker) {
      // Prevent default touch behaviors
      fontPicker.addEventListener('touchstart', (e) => {
        if (e.target.closest('.ql-picker-item')) {
          e.preventDefault();
          e.stopPropagation();
          window.activePickerTouch = true;
        }
      }, { passive: false });
      fontPicker.addEventListener('touchmove', (e) => {
        if (e.target.closest('.ql-picker-item')) {
          e.preventDefault();
          e.stopPropagation();
        }
      }, { passive: false });
      // Add our handler for touch and click
      fontPicker.addEventListener('touchend', handleFontSelection);
      fontPicker.addEventListener('click', handleFontSelection);
      // Handle the picker label
      const fontLabel = fontPicker.querySelector('.ql-picker-label');
      if (fontLabel) {
        fontLabel.addEventListener('touchstart', function (e) {
          window.activePickerTouch = true;
          console.log('Font picker label touched');
          // Reset the flag after a reasonable time
          setTimeout(() => {
            window.activePickerTouch = false;
          }, 1000);
        });
      }
    }
    // Keep using the original mobile picker code just for size picker
    if (sizePicker) {
      const pickerLabel = sizePicker.querySelector('.ql-picker-label');
      if (!pickerLabel) return;
      // When user taps on the picker label
      pickerLabel.addEventListener('touchstart', function (e) {
        // Set active state to help us track interactions
        window.activePickerTouch = true;
        window.lastTouchedPicker = sizePicker;
        // Don't prevent default here - we want the normal dropdown behavior
        console.log(`Touch on ${sizePicker.className}`);
        // We'll reset the flag after a reasonable time
        setTimeout(() => {
          window.activePickerTouch = false;
        }, 1000);
      });
      // Handle taps on the size dropdown options
      sizePicker.addEventListener('touchstart', (e) => {
        if (e.target.closest('.ql-picker-item')) {
          e.preventDefault();
          e.stopPropagation();
          window.activePickerTouch = true;
        }
      }, { passive: false });
      sizePicker.addEventListener('touchmove', (e) => {
        if (e.target.closest('.ql-picker-item')) {
          e.preventDefault();
          e.stopPropagation();
        }
      }, { passive: false });
      // Add our handler for touch and click
      sizePicker.addEventListener('touchend', handleSizeSelection);
      sizePicker.addEventListener('click', handleSizeSelection);
    }
    // Global context menu handler that only prevents when needed
    document.addEventListener('contextmenu', function (e) {
      // Check if we're currently interacting with a picker
      if (window.activePickerTouch) {
        console.log('Preventing context menu during picker interaction');
        e.preventDefault();
        return false;
      }
      // Also prevent if clicking inside any expanded picker
      const expandedPicker = e.target.closest('.ql-picker.ql-expanded');
      if (expandedPicker) {
        console.log('Preventing context menu in expanded picker');
        e.preventDefault();
        return false;
      }
    }, true); // Use capture phase for early interception
  })();

  // Add click handler
  document.querySelector('.ql-find-replace').addEventListener('click', () => {
    const findReplace = snow.getModule('findAndReplace');
    if (findReplace && typeof findReplace.open === 'function') {
      findReplace.open();
    } else {
      console.error('FindAndReplace module not initialized');
    }
  });

  // Color picker handler
  function handleColorSelection(event) {

    const selectedItem = event.target.closest('.ql-picker-item');
    if (!selectedItem) return;
    event.preventDefault();
    event.stopPropagation();

    const selectedColor = selectedItem.getAttribute('data-value');
    if (!selectedColor) return;

    // Get the current selection
    const range = snow.getSelection();
    if (!range) return;

    const formats = snow.getFormat(range.index, Math.max(1, range.length));

    // Store the selection
    const index = range.index;
    const length = range.length;

    // Apply formatting
    if (length > 0) {
      snow.formatText(index, length, {
        ...formats,
        color: selectedColor
      }, 'api');
    } else {
      snow.format('color', selectedColor, 'api');
    }
    // Update UI
    document.querySelectorAll(".ql-picker-item").forEach(item => {
      item.classList.remove("selected");
    });
    selectedItem.classList.add("selected");
    textColorPicker.classList.add("ql-active");

    colorPicker.classList.remove("ql-expanded");

    // **Fix: Temporarily blur and refocus the editor**
    snow.blur(); // Blur first
    snow.focus(); // Refocus after ensuring blur has applied
    snow.setSelection(index, length); // Restore selection
  }

  // Prevent default touch behaviors
  colorPicker.addEventListener('touchstart', (e) => {
    if (e.target.closest('.ql-picker-item')) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive: false });

  colorPicker.addEventListener('touchmove', (e) => {
    if (e.target.closest('.ql-picker-item')) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive: false });

  // Attach both touch and click events
  colorPicker.addEventListener('touchend', handleColorSelection);
  colorPicker.addEventListener('click', handleColorSelection);

  // Background picker handler
  function handleBackgroundSelection(event) {
    const selectedItem = event.target.closest('.ql-picker-item');
    if (!selectedItem) return;

    event.preventDefault();
    event.stopPropagation();

    const selectedBackground = selectedItem.getAttribute('data-value');
    if (!selectedBackground) return;

    const range = snow.getSelection();
    if (!range) return;

    const formats = snow.getFormat(range.index, Math.max(1, range.length));

    // Store the selection
    const index = range.index;
    const length = range.length;

    // Apply formatting
    if (length > 0) {
      snow.formatText(index, length, {
        ...formats,
        background: selectedBackground
      }, 'api');
    } else {
      snow.format('background', selectedBackground, 'api');
    }
    // Update UI
    document.querySelectorAll(".ql-picker-item").forEach(item => {
      item.classList.remove("selected");
    });
    selectedItem.classList.add("selected");
    bgColorPicker.classList.add("ql-active");

    backgroundPicker.classList.remove("ql-expanded");

    // **Fix: Temporarily blur and refocus the editor**
    snow.blur(); // Blur first
    snow.focus(); // Refocus after ensuring blur has applied
    snow.setSelection(index, length); // Restore selection
  }

  // Attach both touch and click events
  backgroundPicker.addEventListener('touchend', handleBackgroundSelection);
  backgroundPicker.addEventListener('click', handleBackgroundSelection);

  // Prevent default touch behaviors
  backgroundPicker.addEventListener('touchstart', (e) => {
    if (e.target.closest('.ql-picker-item')) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive: false });

  backgroundPicker.addEventListener('touchmove', (e) => {
    if (e.target.closest('.ql-picker-item')) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive: false });

  function setupClickToScroll() {
    console.log('Setting up click to scroll');
    const parentDiv = document.getElementById('editor');

    if (!parentDiv) {
      console.error(`Div with id "${divId}" not found.`);
      return;
    }

    parentDiv.addEventListener('click', (event) => {
      // Check if the clicked element is a child of the parent div
      if (parentDiv.contains(event.target)) {
        const clickedElement = event.target;

        // If the clicked target is not the parent div itself
        if (clickedElement !== parentDiv) {
          // Set a timeout to scroll the clicked element into view after 3 seconds
          setTimeout(() => {
            clickedElement.scrollIntoView({
              behavior: 'smooth',
              block: 'center', // Center the element in the view
            });
          }, 300); // 3 seconds delay
        }
      }
    });
  }
  //  setupClickToScroll();

  // Intercept all pasted elements (Node.ELEMENT_NODE === 1)
  snow.clipboard.addMatcher(Node.ELEMENT_NODE, (node, delta) => {
    delta.ops.forEach(op => {
      if (op.insert) {
        op.attributes = {
          ...(op.attributes || {}),
          'font': 'Helvetica',
          'size': '14pt'
        };
      }
    });
    return delta;
  });
  editor.addEventListener('paste', function (e) {
    console.log('Paste detected', e);
    // Use a short timeout to let the paste complete first
    setTimeout(() => {
      // Update the toolbar UI to reflect the applied formatting
      const fontLabel = document.querySelector('.ql-font .ql-picker-label');
      if (fontLabel) {
        fontLabel.setAttribute('data-value', 'Helvetica');
        fontLabel.setAttribute('data-label', 'Helvetica');
      }
      const sizeLabel = document.querySelector('.ql-size .ql-picker-label');
      if (sizeLabel) {
        sizeLabel.setAttribute('data-value', `14pt`);
        sizeLabel.setAttribute('data-label', `14pts`);
      }
      snow.format('font', 'Helvetica', Quill.sources.SILENT);
      snow.format('size', `14pt`, Quill.sources.SILENT);
      const range = snow.getSelection();
      if (range) {
        const format = snow.getFormat(range.index);
        updateToolbarUI(format);
      }
    }, 100); // Increased delay to ensure paste completes fully
  });

 function scrollToCursorPosition(range, options = {}) {
      console.log('[scrollToCursorPosition] called with range:', range, 'options:', options);
      // Default options
      const settings = {
        centerCursor: false,     // Whether to center cursor in viewport
        forceScroll: false,      // Whether to scroll even if cursor is visible
        adjustForKeyboard: false, // Whether to adjust calculation for virtual keyboard
        ...options
      };
      
      // If we have no range, don't scroll at all
      if (!range) {
        console.warn('[scrollToCursorPosition] No range provided');
        return;
      }
      
      // Get ALL possible editor containers
      const editor = document.getElementById('editor');
      const editorContainer = document.querySelector('.ql-editor');
      const editorWrapper = document.querySelector('.ql-container');
      
      console.log('[scrollToCursorPosition] DOM elements:', {
        editor,
        editorContainer,
        editorWrapper
      });
      
      // Ensure we have at least one scroll target
      if (!editor && !editorContainer) {
        console.error('[scrollToCursorPosition] Cannot find editor elements');
        return;
      }
      
      // Use the proper scroll container (prefer editorContainer)
      const scrollTarget = editorContainer || editor;
      
      // Get either Quill selection bounds or DOM range bounds
      let bounds;
      
      
      // If this is a Quill selection object
      if (typeof range.index === 'number') {
        cursorIndex = range.index;
        // Try to get bounds for this index (may fail for high indices)
        try {
          bounds = snow.getBounds(cursorIndex);
          console.log('[scrollToCursorPosition] Got bounds for index:', cursorIndex, bounds);
        } catch (e) {
          console.warn('[scrollToCursorPosition] Error getting bounds for index', cursorIndex, e);
          
          // Try alternative approach
          // Force selection and try again after a small delay
          snow.setSelection(cursorIndex, 0, Quill.sources.USER);
          // We'll continue with approximate bounds based on editor height
          bounds = {
            top: scrollTarget.scrollHeight, // Assume it's at the bottom
            height: 20 // Default line height
          };
        }
      }
      // If this is a DOM range
      else if (typeof range.getBoundingClientRect === 'function') {
        bounds = range.getBoundingClientRect();
        
        // Try to determine the Quill index
        try {
          const node = range.startContainer;
          const blot = Quill.find(node);
          if (blot) {
            cursorIndex = snow.getIndex(blot) + (range.startOffset || 0);
            console.log('[scrollToCursorPosition] Calculated index from DOM range:', cursorIndex);
          }
        } catch (e) {
          console.warn('[scrollToCursorPosition] Error getting index from DOM range', e);
          // Just use the bounds if we can't get the index
        }
      } else {
        // Invalid range object
        console.error('[scrollToCursorPosition] Invalid range object', range);
        return;
      }
      
      // If we couldn't get valid bounds, don't scroll
      if (!bounds || typeof bounds.top !== 'number') {
        console.warn('[scrollToCursorPosition] Invalid bounds', bounds);
        return;
      }
      
      // Get the current viewport dimensions
      const containerRect = scrollTarget.getBoundingClientRect();
      const currentScroll = scrollTarget.scrollTop;
      const viewportHeight = scrollTarget.clientHeight;
      const scrollHeight = scrollTarget.scrollHeight;
      
      console.log('[scrollToCursorPosition] Scroll dimensions:', {
        containerRect,
        currentScroll,
        viewportHeight,
        scrollHeight
      });
      
      // Calculate cursor position relative to the editor
      const cursorPosition = bounds.top - containerRect.top + currentScroll;
      const lineHeight = bounds.height || 20;
      
      // Get the visible area boundaries
      const visibleTop = currentScroll;
      const visibleBottom = visibleTop + viewportHeight;
      
      // Determine if we should center the cursor (for picker selections)
      // or just ensure it's visible (for normal typing)
      let newScrollPosition = currentScroll;
      
      // Different scroll behavior based on options
      if (settings.centerCursor) {
        // CENTER THE CURSOR in the viewport (for picker use)
        
        // Detect virtual keyboard height for mobile devices
        let keyboardAdjustment = 0;
        if (settings.adjustForKeyboard) {
          const visualViewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
          const keyboardHeight = window.innerHeight - visualViewportHeight;
          if (keyboardHeight > 50) { // If keyboard is likely open (height difference > 50px)
            console.log('[scrollToCursorPosition] Detected keyboard height:', keyboardHeight);
            keyboardAdjustment = keyboardHeight / 2; // Adjust centering calculation
          }
        }
        
        // Adjust to position cursor in the middle of the visible area (accounting for keyboard)
        const visibleViewportHeight = viewportHeight - keyboardAdjustment;
        newScrollPosition = cursorPosition - (visibleViewportHeight / 3); // Position at 1/3 instead of 1/2 for better UX
        
        console.log('[scrollToCursorPosition] Centering cursor at position:', cursorPosition,
                    'new scroll position:', newScrollPosition,
                    'keyboard adjustment:', keyboardAdjustment);
      } else {
        // We want comfortable margins around the cursor
        const topMargin = lineHeight * 2;
        const bottomMargin = lineHeight * 2;
        
        // Check if cursor is outside the comfortable visible area
        const isVisible = (cursorPosition >= visibleTop + topMargin &&
                         cursorPosition <= visibleBottom - bottomMargin);
        
        if (!isVisible || settings.forceScroll) {
          if (cursorPosition < visibleTop + topMargin) {
            // Cursor is too close to top - scroll up just enough to give it margin
            newScrollPosition = Math.max(0, cursorPosition - topMargin);
          }
          else if (cursorPosition > visibleBottom - bottomMargin) {
            // Cursor is too close to bottom - scroll down just enough
            newScrollPosition = cursorPosition - viewportHeight + bottomMargin;
          }
        }
      }
      
      // Ensure we stay within bounds
      newScrollPosition = Math.max(0, Math.min(newScrollPosition, scrollTarget.scrollHeight - viewportHeight));
      console.log('[scrollToCursorPosition] Final newScrollPosition:', newScrollPosition, 'current:', currentScroll);
      
      // Only scroll if the change is significant or we're forcing it
      if (settings.forceScroll || Math.abs(newScrollPosition - currentScroll) > lineHeight / 2) {
        // Apply the scroll with appropriate behavior
        const scrollBehavior = 'auto'
        
        console.log(`[scrollToCursorPosition] Scrolling ${scrollTarget === editorContainer ? '.ql-editor' : '#editor'} to:`, newScrollPosition);
        
        // Try scrolling the primary target
        scrollTarget.scrollTo({
          top: newScrollPosition,
          behavior: scrollBehavior
        });
        
        // Also try scrolling parent container as a fallback
        if (editorWrapper && scrollTarget !== editorWrapper) {
          console.log('[scrollToCursorPosition] Also scrolling wrapper for redundancy');
          editorWrapper.scrollTo({
            top: newScrollPosition,
            behavior: scrollBehavior
          });
        }
        // Ensure focus remains on the editor
        //setTimeout(() => editorContainer.focus(), 300);
        // Ensure the cursor is set correctly after scrolling
        if (cursorIndex !== undefined) {
          // Make sure we're not interfering with other operations
          setTimeout(() => {
         
            snow.setSelection(cursorIndex, 0, Quill.sources.API);
            
            console.log('[scrollToCursorPosition] Reset selection to index:', cursorIndex);
          }, 50); // Small delay to let scroll complete
        }
    
      } else {
        console.log('[scrollToCursorPosition] Skipping scroll, not needed or forced');
      }
    }
  


  function applyFormatOnEmptyCell(cell, isFirstCell = false) {
    if (!cell) return;

    snow.focus();

    const range = snow.getSelection();
    if (!range) return;

    // Get the current formats from the cell
    const blot = Quill.find(cell);
    if (!blot) return;

    const cellIndex = snow.getIndex(blot);
    const cellTextLength = blot.length() - 1; // Exclude newline

    // Get active formats from the current selection
    const activeFormats = snow.getFormat(cellIndex, Math.max(1, cellTextLength));
    console.log('activeFormats from cell :>> ', activeFormats);

    // Fetch the default font and size
    const defaultFont = snow.defaultFormats ? snow.defaultFormats.font : '';
    const defaultSize = snow.defaultFormats ? snow.defaultFormats.size : '';

    // Merge the last applied formats with active formats
    // Build the formats to apply: only lastSelectedFormats and defaults
    const mergedFormats = {
      font: lastSelectedFormats.font || defaultFont,
      size: lastSelectedFormats.size || defaultSize,
      bold: lastSelectedFormats.bold,
      italic: lastSelectedFormats.italic,
      underline: lastSelectedFormats.underline,
      strike: lastSelectedFormats.strike,
      color: lastSelectedFormats.color,
      background: lastSelectedFormats.background,
      // Add any other formats you want to preserve
    };

    // Store the merged format for next cell click
    lastSelectedFormats = { ...mergedFormats };
    console.log('Updated lastSelectedFormats :>> ', lastSelectedFormats);

    // If cell is empty, insert a zero-width space to apply formatting
    if (cell.innerText.trim() === '') {
      // Apply formats using USER source for iOS compatibility
      snow.insertText(cellIndex, '\u200B', mergedFormats, Quill.sources.SILENT);

      // Apply formats explicitly to ensure they stick
      // Move cursor back to the correct position after inserting
      snow.setSelection(cellIndex, Quill.sources.SILENT);

      // Only set selection if this is the first cell and we want to position cursor here
      if (isFirstCell) {
        snow.setSelection(cellIndex, 0, Quill.sources.USER);
      }
    } else {
      // If cell already has text, apply formatting directly
      snow.formatText(cellIndex, cellTextLength, mergedFormats, Quill.sources.SILENT);

      // Also apply formats to the current selection
      Object.keys(mergedFormats).forEach(format => {
        if (mergedFormats[format]) {
          snow.format(format, mergedFormats[format], Quill.sources.USER);
        }
      });
    }

    // Force update toolbar UI to reflect active formats
    setTimeout(() => {
      updateToolbarUI(mergedFormats);
    }, 0);
  }



//  Save cursor position before picker opens
  function saveCursorPosition() {
    // First try to get direct selection
    savedRange = snow.getSelection();
    // Fallback to last known range if current selection is null
    if (!savedRange && lastKnownRange) {
      savedRange = lastKnownRange;
      console.log('[saveCursorPosition] Using lastKnownRange as fallback');
    }
    console.log('[saveCursorPosition] savedRange:', savedRange);
  }
    //  Restore selection, scroll to cursor, and ensure cursor is visible
    function restoreCursorAndScroll() {
      console.log('[restoreCursorAndScroll] called, savedRange:', savedRange);
      
      // Use saved range or fallback to last known range
      let rangeToUse = savedRange || lastKnownRange;
      
      if (rangeToUse) {
        // Force a selection update
        snow.setSelection(rangeToUse.index, rangeToUse.length || 0, Quill.sources.SILENT);
        
        // In the next tick, scroll to the cursor and center it
        setTimeout(() => {
          console.log('[restoreCursorAndScroll] calling scrollToCursorPosition for index:', rangeToUse.index);
          scrollToCursorPosition({ index: rangeToUse.index }, { centerCursor: true, forceScroll: true });
        }, 100); // Increased timeout for DOM to settle
      } else {
        console.warn('[restoreCursorAndScroll] No valid range found');
      }
    }


  //  Hook into pickers
  document.querySelectorAll('.ql-picker').forEach(picker => {
    picker.addEventListener('mousedown', saveCursorPosition); // Before picker opens
    // Detect change properly using 'click' on picker items
    //  Ensures scrolling happens after picker updates
    picker.addEventListener('change', () => {
      setTimeout(restoreCursorAndScroll, 100); // Small delay for UI to update first
    });

    // Alternative: Listen to dropdown item selection
    picker.querySelectorAll('.ql-picker-item').forEach(item => {
      item.addEventListener('touchend', () => {
        setTimeout(restoreCursorAndScroll, 100);
      });
    });
  });

  const toolbarSelectors = {
    font: ".ql-font .ql-picker-options .ql-picker-item",
    size: ".ql-size .ql-picker-options .ql-picker-item",
    align: ".ql-align .ql-picker-options .ql-picker-item",
    background: ".ql-background .ql-picker-options .ql-picker-item",
    color: ".ql-color .ql-picker-options .ql-picker-item"
  };
  // Reusable function to handle picker logic
  function handlePicker(selector, type, quillInstance) {
    const options = document.querySelectorAll(selector);

    options.forEach((option) => {
      option.addEventListener("click", (e) => {
        e.preventDefault();
        const value = option.getAttribute("data-value") || null;
        const range = quillInstance.getSelection();
        if(range) cursorIndex = range.index;
        // Update the editor format and toolbar UI in one step
        quillInstance.format(type, value);
        options.forEach((option) => {
          const optionValue = option.getAttribute("data-value") || null;
          if (optionValue === value) {
            option.classList.add("ql-selected");
          } else {
            option.classList.remove("ql-selected");
          }
        });


        // After formatting, center the cursor with a longer delay to let changes and virtual keyboard fully apply
        setTimeout(() => {
          if (cursorIndex !== null) {
          // Force selection update first
          quillInstance.setSelection(cursorIndex, 0, Quill.sources.USER);
                 
          // Then center in viewport with higher priority
          setTimeout(() => {
              console.log('[handlePicker] Attempting to center cursor at index:', cursorIndex);
              scrollToCursorPosition({ index: cursorIndex }, { centerCursor: true, forceScroll: true, adjustForKeyboard: true });
            }, 50);
          }
        }, 200); // Increased delay for mobile
        if (range) {
 
          const [line] = quillInstance.getLine(range.index);
          // Let Quill handle creating the new format

          try {

            if (line && line.domNode) {
              // Check if line contains <br> tag
              const hasBrTag = line.domNode.querySelector('br') !== null;

              if (!hasBrTag) {
                // Check if line is empty (only contains formatting elements or whitespace)
                const lineText = line.domNode.textContent.replace(/[\u200B\s]/g, '');
                // Count formatted elements
                const formattedElements = line.domNode.querySelectorAll('span[class*="ql-font-"], span[style*="font-size"]');
                const hasMultipleFormats = formattedElements.length == 2;
                // Only remove old elements if line is empty and has formatted elements
                if (lineText === '' && hasMultipleFormats) {
                  // Find and remove old formatted elements
                  const oldElements = line.domNode.querySelectorAll('span[class*="ql-font-"], span[style*="font-size"]');
                  oldElements.forEach(el => el.remove());

                }
                // First get the current leaf at cursor position
                const [leaf, offset] = snow.getLeaf(range.index);
                let node = leaf?.domNode;
                // Skip if it's the cursor itself
                if (node.classList && node.classList.contains('ql-cursor')) {
                  node = node.nextSibling || node.parentNode;
                }
                // Find closest styled element (optional: filter by tags like span, strong)
                const formattedNode = node.parentNode?.closest('strong, em, u, s');
                formattedNode.querySelectorAll('*').forEach(child => {
                    child.style.fontSize = 'inherit';
                });
                }
              }
                // Re-select the range to ensure cursor is visible
                quillInstance.setSelection(range.index, 0, 'user');
          } catch (e) {
            console.warn('Format update failed:', e);
          }
        }
      });
    });
  }

    // Function to handle backspace in table cells
  function handleTableCellBackspace(event, quill) {
    const range = quill.getSelection();
    if (!range) return false;
    
    // Get the current block element
    const [block] = quill.getLine(range.index);
    if (!block || !block.domNode) return false;
    
    // Check if we're in a table cell
    let tableCell = block.domNode.closest('td');
    if (!tableCell) return false;
    
    // Get the cell index (position where the cell content starts)
    const cellIndex = quill.getIndex(block);
    
    // Check if we're at the beginning of the cell content
    if (range.index <= cellIndex) {
      // Count the number of paragraph elements in the cell
    const paragraphs = tableCell.querySelectorAll('p, .ql-table-block');
    const hasMultipleLines = paragraphs.length > 1;
    
    // If there are multiple lines, let the default behavior handle it
    // This will allow deleting newlines and merging paragraphs
    if (hasMultipleLines) {
      return false; // Let default behavior handle it
    }
      // Prevent default behavior to avoid moving to previous cell
      event.preventDefault();
      event.stopPropagation();
      
      // Get the table module
      const tableModule = quill.getModule('table-better');
      if (tableModule) {
        // Temporarily disable table balancing to prevent unwanted changes
        const originalBalanceCells = tableModule.balanceCells;
        const originalBalanceTables = tableModule.balanceTables;
        
        tableModule.balanceCells = function() { return; };
        tableModule.balanceTables = function() { return; };
        
        try {
          // Keep focus in the current cell
          quill.setSelection(range.index, 0, Quill.sources.API);
        } finally {
          // Restore original table balancing methods after a delay
          setTimeout(() => {
            tableModule.balanceCells = originalBalanceCells;
            tableModule.balanceTables = originalBalanceTables;
          }, 1500);
        }
      }
      
      return true; // Handled
    }
    
    return false; // Not handled
  }

  function handleBackspace(picker, type, quill) {
    if(!picker) return;
    const range = quill.getSelection(); // Get the current selection in Quill
    let [currentLine, offset] = quill.getLine(range.index);
    let [prevLine] = quill.getLine(range.index - 1);

    // Check if current line is a list and previous line is NOT a list
    if (currentLine && prevLine && currentLine.statics.blotName === 'list' && prevLine.statics.blotName !== 'list') {
      let format = quill.getFormat(range.index);

      // If backspace is pressed at start of list item, prevent merging with non-list
      if (offset === 0) {
        quill.formatText(range.index, 1, 'list', false); // Remove list formatting
      }
    }

    if (range && range.index !== null) {
      // Get the previous format and save it
      const format = quill.getFormat(range.index - 1, 1);
      const isCollapsed = range.length === 0;
      // Save the previous format only if the selection is collapsed (cursor, not range)
      if (isCollapsed) {
        lastFormats = { ...format };
      }
      // Apply the previous format only if it's defined and the selection is collapsed
      if (isCollapsed && lastFormats[type]) {
        quill.format(type, lastFormats[type]);
      }
      // Update the toolbar UI
      const allItems = picker.querySelectorAll(".ql-picker-item");
      allItems.forEach((item) => item.classList.remove("ql-selected"));
      if (lastFormats[type]) {
        const selectedItem = picker.querySelector(`.ql-picker-item[data-value="${lastFormats[type]}"]`);
        if (selectedItem) {
          selectedItem.classList.add("ql-selected");
        }
      }
    }
  }
  let isUpdating = false; // Flag to prevent recursive calls
  let debounceTimer;
  function syncToolbarWithEditor(selector, format, quillInstance) {
    const options = document.querySelectorAll(selector);
    quillInstance.on("editor-change", () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const currentFormat = quillInstance.getFormat()[format] || null;
        // Update toolbar selection (if needed)
        options.forEach((option) => {
          const optionValue = option.getAttribute("data-value") || null;
          if (optionValue === currentFormat) {
            option.classList.add("ql-selected");
          } else {
            option.classList.remove("ql-selected");
          }
        });
      }, 0); // Adjust delay (300ms) as needed
    });
  }

  // Register pickers dynamically
  function registerPickers(toolbarSelectors, quillInstance) {
    for (const [format, selector] of Object.entries(toolbarSelectors)) {
      handlePicker(selector, format, quillInstance);
      syncToolbarWithEditor(selector, format, quillInstance);
    }
  }
  registerPickers(toolbarSelectors, snow);
  // Listen for the backspace key
  document.addEventListener("keydown", (event) => {
    if (event.key === "Backspace") {
      // Handle backspace in table cells first
      if (handleTableCellBackspace(event, snow)) {
        return; // If handled by table handler, skip other handlers
      }
      // First check for empty line case
      // if (handleBackspaceOnEmptyLine(snow, event)) {
      //   // If the empty line case was handled, we're done
      //   return;
      // }
      // Pass the relevant picker and format type to the backspace handler
      handleBackspace(document.querySelector(toolbarSelectors.font), "font", snow);
      handleBackspace(document.querySelector(toolbarSelectors.size), "size", snow);
      handleBackspace(document.querySelector(toolbarSelectors.align), "align", snow);
      handleBackspace(document.querySelector(toolbarSelectors.background), "background", snow);
      handleBackspace(document.querySelector(toolbarSelectors.color), "color", snow);
    }
    else if (event.key === "Enter") {
      isKeyboardOperation = true;
      // Allow Enter key to work normally
      setTimeout(() => {
        isKeyboardOperation = false;
      }, 50);
    }
  }, { capture: true, passive: false });

  function applyStylesToListElements(editor) {
    const range = editor.getSelection();
    if (!range) return;

    // Get the current block (line) and check if it's a list item (LI)
    const [block, offset] = editor.getLine(range.index);
    if (block && block.domNode.tagName === 'LI') {
      const liElement = block.domNode;

      // Get all applied formats dynamically
      const formats = editor.getFormat(range);

      // Clear previous inline styles (optional)
      liElement.style = '';

      // Dynamically apply all relevant formats to the <li> tag
      Object.keys(formats).forEach((key) => {
        switch (key) {
          case 'size':
            liElement.style.fontSize = formats[key];
            break;
          case 'font':
            liElement.style.fontFamily = formats[key];
            break;
          case 'color':
            liElement.style.color = formats[key];
            break;
          case 'background':
            liElement.style.backgroundColor = formats[key];
            break;
          case 'bold':
            liElement.style.fontWeight = formats[key] ? 'bold' : '';
            break;
          case 'italic':
            liElement.style.fontStyle = formats[key] ? 'italic' : '';
            break;
          case 'underline':
            liElement.style.textDecoration = formats[key] ? 'underline' : '';
            break;
          default:
            // Handle other formats as needed
            break;
        }
      });
    }
  }


  //keyboard height manage function - for both iphone and ipad
  function adjustForKeyboard() {

    const toolbar = document.getElementById('toolbar');
    const editor = document.getElementById('editor');
    const toolbarHeight = toolbar.offsetHeight || 0;

    if (window.visualViewport) {
      const viewportHeight = window.visualViewport.height;
      const height = window.innerHeight - viewportHeight;
      keyboardHeight = height;
      if (keyboardHeight > 0) {
        // Keyboard is open  Adjust height with 20px gap
        const adjustedHeight = viewportHeight - toolbarHeight - 20;
        editor.style.height = `${adjustedHeight}px`;
      } else {
        // Keyboard is closed  Full screen height minus 10px for blue button
        editor.style.height = `calc(100vh - ${toolbarHeight + 10}px)`;
      }
    }
  }

  //  Apply on both iPhones & iPads
  window.visualViewport.addEventListener('resize', adjustForKeyboard);
  window.addEventListener('orientationchange', adjustForKeyboard); // Handle device rotation

  $("#btnscrollToBottom").click(function () {
    const $editable = $('.ql-editor');
    const height = $editable[0].scrollHeight;


    $("#MakeUIWorkForEdit").click(function () {
      snow.root.scrollTop = 0;
    });

    function scrollToCursor() {
      var range = snow.getSelection();
      if (range) {
        var bounds = snow.getBounds(range.index, range.length);
        snow.root.scrollTop = bounds.top;
      }
    }



    $("#ScrollToCursorPosition").click(function () {
      scrollToCursor();
    });
    console.log('scroll height: ', height);

    $editable.animate({
      scrollTop: height
    }, 500);
  });

  function getTextOfRichTextEditorEdit() {
    snow.enable(true);
    const editor = document.querySelector('.ql-editor');
    // Don't auto-focus on load - only focus when user explicitly interacts
    // editor.focus();
    // editor.click();
    const root = snow.root;
    const selectionPosition = Math.round(root.scrollTop / (root.scrollHeight - root.clientHeight) * snow.getLength());
    snow.setSelection(selectionPosition || 0);
   // document.getElementById('toolbar').style.display = 'block';
    const range = window.getSelection().getRangeAt(0); // Get the current selection
    if (range) {
      scrollToCursorPosition(range, { centerCursor: true, forceScroll: true });
    }
  }


  function setTapToEdit(isTabToEdit, isVersionAvailable) {
    const toolbar = document.getElementById('toolbar');
    const editor = document.getElementById('editor');
    const toolbarHeight = toolbar.offsetHeight;

    if (window.visualViewport) {
      const viewportHeight = window.visualViewport.height;
    }
    if(document.getElementById('toolbar').style.display == "block"){
      return;
    }
    if (isTabToEdit) {
      document.getElementById('toolbar').style.display = 'none';
      if (isVersionAvailable) {
        snow.enable(false);
      } else {
        snow.enable(true);
        isPlanNote = false;
        editor.style.height = `calc(100vh - 10px)`;
        const parentDiv = document.getElementById('editor');
        parentDiv.addEventListener('click', (event) => {
          document.getElementById('toolbar').style.display = 'block';
        })
      }
    } else {
      snow.enable(false);
      editor.style.height = `calc(100vh - 10px)`;
      document.getElementById('toolbar').style.display = 'none';
    }
  }

  function setFontStyle(fontName, fontSize) {
    // Save the current selection
    const currentSelection = snow.getSelection();
    const isFocused = document.activeElement === snow.container;

    // Find the font dropdown in the toolbar
    const fontDropdown = document.querySelector('.ql-font .ql-picker-options');
    if (fontDropdown) {
      const fontOption = fontDropdown.querySelector(`.ql-picker-item[data-value="${fontName}"]`);
      if (fontOption) {
        fontOption.click();
        const fontLabel = document.querySelector('.ql-font .ql-picker-label');
        if (fontLabel) {
          fontLabel.setAttribute('data-value', fontName);
          fontLabel.setAttribute('data-label', fontName);
          //fontLabel.innerText = fontOption.getAttribute('data-label');
        }
      } else {
        console.error(`Font "${fontName}" not found.`);
      }
    }
    const sizeDropdown = document.querySelector('.ql-size .ql-picker-options');
    if (sizeDropdown) {
      const sizeOption = sizeDropdown.querySelector(`.ql-picker-item[data-value="${fontSize}pt"]`);
      if (sizeOption) {
        sizeOption.click();
        const sizeLabel = document.querySelector('.ql-size .ql-picker-label');
        if (sizeLabel) {
          sizeLabel.setAttribute('data-value', `${fontSize}pt`);
          sizeLabel.setAttribute('data-label', `${fontSize}pts`);
          //sizeLabel.innerText = sizeOption.getAttribute('data-label');
        }
      } else {
        console.error(`Font size "${fontSize}pt" not found.`);
      }
    }
    // Apply formatting without triggering focus
    snow.format('font', fontName, Quill.sources.SILENT);
    snow.format('size', `${fontSize}pt`, Quill.sources.SILENT);
    // Save default formats globally by attaching them to the Quill instance
    snow.defaultFormats = {
      font: fontName,
      size: `${fontSize}pt`
    };

    // Set global default formats for reference elsewhere
    defaultFormats = snow.defaultFormats;

    // Also update lastFormats which is used in some event handlers
    lastFormats = {
      font: fontName,
      size: `${fontSize}pt`
    };

    // Apply to globalLastUsedFormat to ensure format persistence
    if (typeof globalLastUsedFormat !== 'undefined') {
      globalLastUsedFormat.font = fontName;
      globalLastUsedFormat.size = `${fontSize}pt`;
    }


    // Restore previous selection
    if (currentSelection) {
      snow.setSelection(currentSelection, Quill.sources.SILENT);
    }

    let marginTop = 0;
    let marginTops = 0;
    if(fontSize == '14'){
      marginTop = '3px';
      marginTops = '-2px';
    }else if(fontSize == '16'){
      marginTop = '5px';
      marginTops = '1px';
    }else {
      marginTop = '7px';
      marginTops = '1px';
    }
    // Get or create the style element for dynamic list styling
    let styleElement = document.getElementById('dynamic-list-styles');
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.id = 'dynamic-list-styles';
      document.head.appendChild(styleElement);
    }

   let styleElements = document.getElementById('dynamics-list-styles');
   if (!styleElements) {
    styleElements = document.createElement('style');
    styleElements.id = 'dynamics-list-styles';
    document.head.appendChild(styleElements);
   }
   // Update the CSS for list items only
   styleElements.textContent = `
    .ql-editor li[data-list="ordered"] > .ql-ui:before {
     margin-top : ${marginTop} !important;
    }
   `;

    styleElement.textContent = `
      .ql-editor li[data-list="bullet"] > .ql-ui:before {
      margin-top : ${marginTops} !important;
      }
    `;
    console.log(`Updated list styling - Size: ${fontSize}`);

  }



  function manageKeyboardHeightBasedOnMedia(isMedia) {

    const editor = document.getElementById('editor');
    const toolbar = document.getElementById('toolbar');
    const toolbarHeight = toolbar.offsetHeight || 0; // Handle case where toolbar is hidden

    // 10px gap from the blue button

    if (window.visualViewport) {
      const viewportHeight = window.visualViewport.height;
      const keyboardHeight = window.innerHeight - viewportHeight;
    }
    if (keyboardHeight > 0) {
      editor.style.height = viewportHeight - toolbarHeight - 20;
    } else {
      if (isMedia === 'false') {

        if (toolbar.style.display == 'none') {
          editor.style.height = `calc(100vh - 10px)`;
        } else {
          editor.style.height = `calc(100vh - ${toolbarHeight + 10}px)`;
        }
        // window.webkit.messageHandlers.callbackHandler.postMessage('isMedia add');
        // editor.style.height = `calc(100vh - ${toolbarHeight + blueButtonMargin}px)`;
      } else {

        // window.webkit.messageHandlers.callbackHandler.postMessage('isMedia remove');

        if (toolbar.style.display == 'none') {
          editor.style.height = `calc(100vh - 10px)`;
        } else {
          editor.style.height = `calc(100vh - ${toolbarHeight + 130}px)`;
        }

      }
    }
  }

  function changeThePlaceHolder(newPlaceholder) {
    snow.root.setAttribute('data-placeholder', `${newPlaceholder}`);
  }


  var globalLastUsedFormat = {
    font: snow.defaultFormats?.font ?? '',     // Empty default - no font
    size: snow.defaultFormats?.size ?? '',     // Empty default - no size
    bold: false,
    italic: false,
    underline: false,
    strike: false,
    color: null,
    background: null
  };


    // Utility function for handling empty line click formatting
    function handleEmptyLineClick(quill, index) {
      const range = quill.getSelection();
      if (!range) return;

      // Get the current line
      const [currentLine] = quill.getLine(range.index);
      if (!currentLine || !currentLine.domNode) return;

      // Check if this is an empty line (just a <br> or empty)
      const isEmpty = currentLine.domNode.innerHTML === '<br>' ||
        currentLine.domNode?.textContent?.trim() === '';

      if (isEmpty) {
        // Look for a previous non-empty line to get formats from
        let prevLine = currentLine.prev;
        let previousElement = null;

        // Try to find the nearest non-empty line above
        while (prevLine && !previousElement) {
          if (prevLine.domNode) {
            const inner = prevLine.domNode.innerHTML.trim();
            const isOnlyNbsp = (
              inner === '&nbsp;' ||
              inner === '<p>&nbsp;</p>' ||
              inner === '<p>\u00A0</p>' || // actual Unicode char
              inner.replace(/\s|&nbsp;|<br>/g, '') === '' // more aggressive cleanup
            );
            if (
              !isOnlyNbsp ||
              prevLine.domNode.textContent.trim() !== '' &&
              inner !== '<br>'
            ) {
              // Get only the last meaningful element
              const lastElementContainer = getLastMeaningfulElement(prevLine.domNode);
              previousElement = lastElementContainer || prevLine.domNode;
              console.log("Found element:", previousElement.innerHTML);
              break;
            }
          }
          prevLine = prevLine.prev;
        }

        let isPrevTable = false;
        if (previousElement && previousElement.tagName === 'TABLE') {
          isPrevTable = true;
        }

        // After the while loop
        let aboveFormat = null;
        let prevIndex = null;
        if (prevLine) {
          prevIndex = quill.getIndex(prevLine);
        } else if (previousElement) {
          const prevBlot = Quill.find(previousElement);
          if (prevBlot) {
            prevIndex = snow.getIndex(prevBlot);
          }
        }
        if (prevIndex !== null) {
          aboveFormat = snow.getFormat(prevIndex, 1);
          // Get the color from the previous line - specifically the last active color
          if (previousElement) {
            try {
              // Extract font directly from the HTML class
              let extractedFont = null;

              // Direct extraction from class attribute
              if (previousElement.outerHTML) {
                const fontClassMatch = previousElement.outerHTML.match(/class="[^"]*ql-font-([^"\s]+)/);
                if (fontClassMatch && fontClassMatch[1]) {
                  extractedFont = fontClassMatch[1];
                  console.log("Directly extracted font name from class:", extractedFont);
                }
              }

              // Check for data attribute if direct extraction failed
              if (!extractedFont && previousElement.hasAttribute && previousElement.hasAttribute('data-extracted-font')) {
                extractedFont = previousElement.getAttribute('data-extracted-font');
                console.log("Found extracted font name from attribute:", extractedFont);
              }

              // Apply the extracted font immediately if found
              if (extractedFont) {
                aboveFormat.font = extractedFont;
                // Also apply it directly to ensure it takes effect
                console.log("Directly applying font format:", extractedFont);
                snow.format('font', extractedFont, Quill.sources.USER);

                // Update the toolbar UI
                const fontPicker = document.querySelector('.ql-font');
                const fontLabel = fontPicker?.querySelector('.ql-picker-label');
                if (fontLabel) {
                  fontLabel.setAttribute('data-value', extractedFont);
                  // Update selected item in dropdown
                  const selectedItem = fontPicker.querySelector(`.ql-picker-item[data-value="${extractedFont}"]`);
                  if (selectedItem) {
                    fontPicker.querySelectorAll('.ql-picker-item').forEach(item => {
                      item.setAttribute('data-selected', 'false');
                    });
                    selectedItem.setAttribute('data-selected', 'true');
                  }
                }
              }
              // Try multiple approaches to find color
              let color = null;
              // Approach 1: Check for direct RGB color in the HTML
              if (previousElement.innerHTML) {
                const rgbMatch = previousElement.innerHTML.match(/color:\s*rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
                if (rgbMatch) {
                  color = `rgb(${rgbMatch[1]}, ${rgbMatch[2]}, ${rgbMatch[3]})`;
                }
              }

              // Approach 2: Check for computed style on the element itself
              if (!color) {
                try {
                  const computedStyle = window.getComputedStyle(previousElement);
                  if (computedStyle.color && computedStyle.color !== 'rgb(0, 0, 0)') {
                    color = computedStyle.color;
                  }
                } catch (e) {
                  console.warn("Error getting computed style:", e);
                }
              }

              // Apply the found color
              if (color) {
                aboveFormat.color = color;
                // Update the toolbar UI with the color
                updateToolbarUI({ color: color });
              }
            } catch (e) {
              console.warn("Error getting last active color:", e);
            }
          }
                // Check if any table-related formats exist
                const hasTableFormats = Object.keys(aboveFormat || {}).some(key =>
                  key.includes('table') || key.includes('cell') || key.includes('row') ||
                  key === 'td' || key === 'th' || key === 'tr'
                );

                if (hasTableFormats) {
                  console.log("Previous format contains table formats, applying only font and size");
                  // Apply only font and size, not table formats

                  const fontSizeFormat = {};
                  // Also include other non-table formats like bold, italic, etc.
                  Object.keys(aboveFormat).forEach(key => {
                    if (!key.includes('table') && !key.includes('cell') && !key.includes('row') &&
                      key !== 'td' && key !== 'th' && key !== 'tr') {
                      fontSizeFormat[key] = aboveFormat[key];
                    }
                  });

                  snow.format('font', fontSizeFormat.font, Quill.sources.SILENT);
                  snow.format('size', fontSizeFormat.size, Quill.sources.SILENT);
                  updateToolbarUI(fontSizeFormat);
                  snow.setSelection(index, 0, Quill.sources.SILENT);

                  return; // Exit without applying other formats
                }
              }
        let formatToApply = null;

        if (!isPrevTable && aboveFormat && Object.keys(aboveFormat).length > 0) {
          formatToApply = filterOutTableFormats(aboveFormat);
        } else {
          formatToApply = filterOutTableFormats(lastSelectedFormats);
        }
        // Apply default formats if we're on the first line and no formatting is available
        if ((!previousElement || !prevLine) && (!formatToApply || Object.keys(formatToApply).length === 0)) {
          // Get the next line and its formatting using descendant to find the next block
          const [nextLine] = snow.scroll.descendant(Quill.import('blots/block'), index + 1);
          if (nextLine && nextLine !== currentLine) {
            // Set previousElement to the DOM node of the next line
            previousElement = nextLine.domNode;
            // return;
          }
          else {
            // If we couldn't find or use next line formatting, fall back to defaults
            formatToApply = {
              font: snow.defaultFormats?.font || '',
              size: snow.defaultFormats?.size || ''
            };
          }
        }
        snow.formatLine(index, 0, formatToApply, Quill.sources.USER);
        // Ensure color is applied correctly
        if (formatToApply && formatToApply.color) {
          snow.format('color', formatToApply.color, Quill.sources.USER);
        }
        // First, add this helper function at the top of your file
        function getLastMeaningfulElement(element) {
          if (!element) return null;
          const tempDiv = document.createElement('div');
          let containerElement = null;
          // If we're working with a DOM element directly
          if (element.nodeType === 1) {
            // Clone the entire element to preserve all formatting
            tempDiv.innerHTML = element.outerHTML || element.innerHTML;
          } else {
            // Otherwise use the innerHTML
            tempDiv.innerHTML = element.innerHTML;
          }
          // Log the HTML structure for debugging
          console.log("Original HTML structure:", tempDiv.innerHTML);



        // CASE 0: First priority - Find spans with font class
        const fontSpans = tempDiv.querySelectorAll('[class*="ql-font-"]');
        if (fontSpans.length > 0) {
          // Use the last span with font (most recently applied font)
          const lastFontSpan = fontSpans[fontSpans.length - 1];
          console.log("Found span with font class:", lastFontSpan.outerHTML);

          // Find the parent paragraph or container of the font span
          let fontParent = lastFontSpan.parentNode;
          while (fontParent && fontParent !== tempDiv) {
            if (fontParent.tagName === 'P' || fontParent.tagName === 'DIV') {
              // We found the paragraph containing the font span
              containerElement = fontParent;
              console.log("Found paragraph with font:", containerElement.outerHTML);

              // Return the container with all formatting intact
              const container = document.createElement('div');
              container.appendChild(containerElement.cloneNode(true));
              console.log("Returning formatted element with font and all formats:", container.innerHTML);
              return container;
            }
            fontParent = fontParent.parentNode;
          }

          // If we didn't find a paragraph, use the font span itself
          containerElement = lastFontSpan;
          const container = document.createElement('div');
          container.appendChild(containerElement.cloneNode(true));
          return container;
        }

          // CASE 1: First priority - Find spans with color styling
          const colorSpans = tempDiv.querySelectorAll('[style*="color"]');
          if (colorSpans.length > 0) {
          // Use the last span with color (most recently applied color)
          const lastColorSpan = colorSpans[colorSpans.length - 1];
          // Find the parent paragraph or container of the color span
          let colorParent = lastColorSpan.parentNode;
          while (colorParent && colorParent !== tempDiv) {
            if (colorParent.tagName === 'P' || colorParent.tagName === 'DIV') {
            // We found the paragraph containing the color span
            containerElement = colorParent;
            // Return the container with all formatting intact
            const container = document.createElement('div');
            container.appendChild(containerElement.cloneNode(true));
            return container;
          }
          colorParent = colorParent.parentNode;
        }
        // If we didn't find a paragraph, use the color span itself
        containerElement = lastColorSpan;
      }
          if(!containerElement){
              // Find all elements with text content or formatting
              const allElements = [];
              // Helper function to find elements with formatting or text content
              function findFormattedElements(node, path = []) {
                if (!node) return;
                // If this is a text node with content, record its path
                if (node.nodeType === 3 && node.textContent.trim() !== '') {
                  // We found text content, record the path to it
                  allElements.push({
                    path: [...path],
                    node: node,
                    hasText: true
                  });
                  return;
                }
                // If this is an element node
                if (node.nodeType === 1) {
                  // Record this element if it has formatting attributes
                  if (node.tagName === 'STRONG' ||
                    node.tagName === 'B' ||
                    node.tagName === 'EM' ||
                    node.tagName === 'I' ||
                    node.tagName === 'U' ||
                    node.tagName === 'S' ||
                    node.tagName === 'SPAN' ||
                    node.hasAttribute('class') ||
                    node.hasAttribute('style')) {
                    allElements.push({
                      path: [...path],
                      node: node,
                      hasFormat: true
                    });
                  }
                  // Traverse children
                  Array.from(node.childNodes).forEach((child, index) => {
                    findFormattedElements(child, [...path, index]);
                  });
                }
              }
              // Start traversal from the root
              findFormattedElements(tempDiv);
              // No elements found at all
              if (allElements.length === 0) return null;
              // Find elements that have both text and formatting
              // Sort by path length to find the deepest elements first
              allElements.sort((a, b) => b.path.length - a.path.length);
              // Find the last text element
              const textElements = allElements.filter(e => e.hasText);
              if (textElements.length === 0) return null;
              const lastTextElement = textElements[0];
              // Now find the outermost parent with formatting that contains this text
              let currentNode = lastTextElement.node;
              let parent = currentNode.parentNode;
              // Climb up the tree until we find a parent with formatting
              // or until we hit the root div
              while (parent && parent !== tempDiv) {
                // Check if this parent has formatting
                if (parent.tagName === 'STRONG' ||
                  parent.tagName === 'B' ||
                  parent.tagName === 'EM' ||
                  parent.tagName === 'I' ||
                  parent.tagName === 'U' ||
                  parent.tagName === 'S' ||
                  parent.tagName === 'SPAN' ||
                  parent.hasAttribute('class') ||
                  parent.hasAttribute('style')) {
                  // We found a formatting parent, remember it
                  currentNode = parent;
                }
                parent = parent.parentNode;
              }
              containerElement = currentNode;
            }
              // Now that we've found the outermost formatting element,
              // let's clone it to return
              const container = document.createElement('div');
              container.appendChild(containerElement.cloneNode(true));
              console.log("Returning formatted element:", container.innerHTML);
              return container;
            }


          if (previousElement) {
          // Get the last meaningful element with its formatting
          const lastMeaningfulContainer = getLastMeaningfulElement(previousElement);

          if (lastMeaningfulContainer && lastMeaningfulContainer.firstElementChild) {
            const lastElement = lastMeaningfulContainer.firstElementChild;

            // Copy the exact element with all its attributes
            let html = lastElement.outerHTML.replace(/>.*<\//, '>\u200B</');

            // Replace the current line's content with the cloned structure
            currentLine.domNode.innerHTML = html;
            console.log(html);

            // Extract all formatting elements from the previous line
            const formatElements = {
              bold: previousElement.querySelector('strong, b'),
              italic: previousElement.querySelector('em, i'),
              underline: previousElement.querySelector('u'),
              strike: previousElement.querySelector('s, strike'),
              font: previousElement.querySelector('span[class*="ql-font-"], span[style*="font"]'),
              color : previousElement.querySelector('[style*="color"]'),
              background : previousElement.querySelector('[style*="background-color"]')
            };
            
            // Create a combined HTML structure that preserves all formats
            let combinedHtml = '';
            let innerContent = '\u200B'; // Zero-width space for cursor positioning
            
            // Build nested HTML structure from inside out
            if (formatElements.italic) {
              const className = formatElements.italic.getAttribute('class') || '';
              const style = formatElements.italic.getAttribute('style') || '';
              innerContent = `<em ${className ? `class="${className}"` : ''} ${style ? `style="${style}"` : ''}>${innerContent}</em>`;
            }
            
            if (formatElements.underline) {
              const className = formatElements.underline.getAttribute('class') || '';
              const style = formatElements.underline.getAttribute('style') || '';
              innerContent = `<u ${className ? `class="${className}"` : ''} ${style ? `style="${style}"` : ''}>${innerContent}</u>`;
            }
            
            if (formatElements.strike) {
              const className = formatElements.strike.getAttribute('class') || '';
              const style = formatElements.strike.getAttribute('style') || '';
              innerContent = `<s ${className ? `class="${className}"` : ''} ${style ? `style="${style}"` : ''}>${innerContent}</s>`;
            }
            
            if (formatElements.bold) {
              const className = formatElements.bold.getAttribute('class') || '';
              const style = formatElements.bold.getAttribute('style') || '';
              innerContent = `<strong ${className ? `class="${className}"` : ''} ${style ? `style="${style}"` : ''}>${innerContent}</strong>`;
            }
            
            if (formatElements.font) {
              const className = formatElements.font.getAttribute('class') || '';
              const style = formatElements.font.getAttribute('style') || '';
              innerContent = `<span ${className ? `class="${className}"` : ''} ${style ? `style="${style}"` : ''}>${innerContent}</span>`;
            }

            if (formatElements.color) {
              const className = formatElements.color.getAttribute('class') || '';
              const style = formatElements.color.getAttribute('style') || '';
              const dataColor = formatElements.color.getAttribute('data-color') || '';
              const colorStyle = style || (dataColor ? `color: ${dataColor};` : '');
              innerContent = `<span ${className ? `class="${className}"` : ''} ${colorStyle ? `style="${colorStyle}"` : ''} ${dataColor ? `data-color="${dataColor}"` : ''}>${innerContent}</span>`;
            }

            if (formatElements.background) {
              const className = formatElements.background.getAttribute('class') || '';
              const style = formatElements.background.getAttribute('style') || '';
              const dataBackground = formatElements.background.getAttribute('data-background') || '';
              const bgStyle = style || (dataBackground ? `background-color: ${dataBackground};` : '');
              innerContent = `<span ${className ? `class="${className}"` : ''} ${bgStyle ? `style="${bgStyle}"` : ''} ${dataBackground ? `data-background="${dataBackground}"` : ''}>${innerContent}</span>`;
            }
            
            // If we found any format to apply
            if (innerContent !== '\u200B') {
              combinedHtml = innerContent;
              
              // Replace the current line's content with the combined structure
              currentLine.domNode.innerHTML = combinedHtml;
              
              setTimeout(() => {
              // Use the dedicated function for cursor positioning
              positionCursorAtEmptyLine(quill, currentLine);
            }, 10);
            }
          }
        }
      }
    }

  // Function to position cursor at the beginning of an empty line (before the zero-width space)
  function positionCursorAtEmptyLine(quill, line) {
    if (!quill || !line || !line.domNode) return;

    try {
      // Find the text node containing the zero-width space
      function findZeroWidthSpaceNode(node) {
        if (node.nodeType === 3 && node.textContent.includes('\u200B')) {
          return node;
        }

        if (node.childNodes) {
          for (let i = 0; i < node.childNodes.length; i++) {
            const found = findZeroWidthSpaceNode(node.childNodes[i]);
            if (found) return found;
          }
        }

        return null;
      }

      // Find the text node with zero-width space
      const textNode = findZeroWidthSpaceNode(line.domNode);

      if (textNode) {
        // Create a range at the beginning of the text node (before the zero-width space)
        const range = document.createRange();
        range.setStart(textNode, 0);
        range.collapse(true);

        // Apply the range to the selection
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        // Ensure the editor is focused
       if (!window.isSearchPanelOpen) {
            quill.focus();
          }

        // Update Quill's internal selection
        setTimeout(() => {
          const index = quill.getIndex(Quill.find(textNode.parentNode));
          if (index !== undefined) {
            quill.setSelection(index, 0);
          }
        }, 0);
      } else {
        // Fallback if we can't find the text node
        const index = quill.getIndex(line);
        quill.setSelection(index, 0);
      }
    } catch (e) {
      console.error("Error positioning cursor:", e);
      // Fallback to default selection
      try {
        const index = quill.getIndex(line);
        quill.setSelection(index, 0);
      } catch (err) {
        console.error("Fallback positioning failed:", err);
      }
    }
  }

   // Fix cursor overlapping issue when typing on empty lines
  snow.on('text-change', function (delta, oldDelta, source) {
    if (source !== 'user') return;

    // Check if delta contains any inserts (typing)
    if (delta.ops && delta.ops.some(op => op.insert)) {
      const range = snow.getSelection();
      if (!range) return;

      // Get the current line
      const [line] = snow.getLine(range.index);
      if (!line || !line.domNode) return;

      // Check if this line contains a zero-width space character
      const text = line.domNode.textContent;

      // Only process if there's actual text along with the zero-width space
      // This ensures we don't remove the zero-width space on empty lines
      if (text && text.includes('\u200B') && text.replace(/\u200B/g, '').trim().length > 0) {
        // Get the current formats before modifying anything
        const currentFormats = snow.getFormat(range);

        // Find the text node containing the zero-width space
        function findAndFixZeroWidthSpace(node) {
          if (node.nodeType === 3 && node.textContent.includes('\u200B')) {
            // Save the selection and cursor position
            const savedRange = snow.getSelection();
            const savedOffset = window.getSelection().focusOffset;

            // Only remove the zero-width space if there's other content
            if (node.textContent.replace(/\u200B/g, '').trim().length > 0) {
              // Remove the zero-width space
              const newText = node.textContent.replace(/\u200B/g, '');
              const removedChars = node.textContent.length - newText.length;
              node.textContent = newText;

              // Restore the selection with adjusted offset
              if (savedRange) {
                setTimeout(() => {
                  // Adjust the offset if the cursor was after the zero-width space
                  if (savedOffset > removedChars) {
                    savedRange.index -= removedChars;
                  }
                  snow.setSelection(savedRange);

                  // Re-apply the formats to ensure they're preserved
                  if (currentFormats && Object.keys(currentFormats).length > 0) {
                    // Apply each format individually
                    Object.keys(currentFormats).forEach(format => {
                      if (currentFormats[format] !== null && currentFormats[format] !== undefined) {
                        snow.format(format, currentFormats[format], Quill.sources.SILENT);
                      }
                    });
                  }
                }, 0);
              }
              return true;
            }
          }

          if (node.childNodes) {
            for (let i = 0; i < node.childNodes.length; i++) {
              if (findAndFixZeroWidthSpace(node.childNodes[i])) {
                return true;
              }
            }
          }

          return false;
        }

        findAndFixZeroWidthSpace(line.domNode);
      }
    }
  });


  function filterOutTableFormats(formats) {
    const tableKeys = ['table', 'tableCell', 'row', 'table-row', 'cell', 'cell-line', 'cell-row', 'cell-col'];
    const result = {};
    Object.keys(formats || {}).forEach(key => {
      if (!tableKeys.includes(key)) {
        result[key] = formats[key];
      }
    });
    return result;
  }


  // Add a new function to update toolbar based on cell selection
  function updateToolbarFromCell(e) {
    // Only process if we clicked on a table cell
    const cell = e.target.closest('td');
    if (!cell) return;

    // Get the cell's formats without modifying anything
    const cellBlot = Quill.find(cell);
    if (!cellBlot) return;

    // Get the formats from the cell
    const cellIndex = snow.getIndex(cellBlot);
    let cellFormats = snow.getFormat(cellIndex, 1);

    // Check if cell is empty
    const cellText = cell.textContent.trim();
    const isEmpty = cellText === '' || cellText === '\u200B'; // Zero-width space

    // If cell is empty, apply last used formatting
    if (isEmpty && lastSelectedFormats) {
      cellFormats = { ...lastSelectedFormats, ...cellFormats };
      console.log("Empty cell - applying last used formats:", cellFormats);
    }

    console.log("Cell formats detected:", cellFormats);

    // Store current formats globally
    window.currentCellFormats = cellFormats;

    // DIRECTLY manipulate toolbar buttons without changing selection

    // Format buttons (boolean formats)
    const booleanFormats = ['bold', 'italic', 'underline', 'strike'];
    booleanFormats.forEach(format => {
      const button = document.querySelector(`.ql-${format}`);
      if (button) {
        // Force add ql-active class if format is true
        if (cellFormats[format] === true) {
          button.classList.add('ql-active');
          console.log(`Added ql-active to ${format} button`);
        } else {
          button.classList.remove('ql-active');
          console.log(`Removed ql-active from ${format} button`);
        }
      }
    });

    // Font dropdown
    if (cellFormats.font) {
      const fontPicker = document.querySelector('.ql-font');
      const fontLabel = fontPicker?.querySelector('.ql-picker-label');
      if (fontLabel) {
        fontLabel.setAttribute('data-value', cellFormats.font);

        // Update selected item in dropdown
        const selectedItem = fontPicker.querySelector(`.ql-picker-item[data-value="${cellFormats.font}"]`);
        if (selectedItem) {
          // Remove selected from all items
          fontPicker.querySelectorAll('.ql-picker-item').forEach(item => {
            item.setAttribute('data-selected', 'false');
          });
          // Mark this one as selected
          selectedItem.setAttribute('data-selected', 'true');
        }
      }
    }

    // Size dropdown
    if (cellFormats.size) {
      const sizePicker = document.querySelector('.ql-size');
      const sizeLabel = sizePicker?.querySelector('.ql-picker-label');
      if (sizeLabel) {
        sizeLabel.setAttribute('data-value', cellFormats.size);

        // Update selected item in dropdown
        const selectedItem = sizePicker.querySelector(`.ql-picker-item[data-value="${cellFormats.size}"]`);
        if (selectedItem) {
          // Remove selected from all items
          sizePicker.querySelectorAll('.ql-picker-item').forEach(item => {
            item.setAttribute('data-selected', 'false');
          });
          // Mark this one as selected
          selectedItem.setAttribute('data-selected', 'true');
        }
      }
    }

    // Color picker
    if (cellFormats.color) {
      const colorPicker = document.querySelector('.ql-color');
      const colorLabel = colorPicker?.querySelector('.ql-picker-label');
      if (colorLabel) {
        colorLabel.style.color = cellFormats.color;
        colorLabel.style.stroke = cellFormats.color;
      }
    }

    // Background color picker
    if (cellFormats.background) {
      const bgPicker = document.querySelector('.ql-background');
      const bgLabel = bgPicker?.querySelector('.ql-picker-label');
      if (bgLabel) {
        bgLabel.style.backgroundColor = cellFormats.background;
        bgLabel.style.fill = cellFormats.background;
      }
    }
  }

  // Add event listeners with high priority (capture: true)
  // This ensures our handler runs first, before other handlers
  editor.addEventListener('click', function(e) {
    const cell = e.target.closest('td');
    if (cell) {
      // Don't stop propagation - let normal click handling occur
      // This ensures keyboard opens and cursor appears
      
      // Remove focus and conflicting selection classes from ALL cells
      document.querySelectorAll('td').forEach(c => {
        c.classList.remove('ql-cell-focused');
        c.classList.remove('ql-cell-selected');
        c.classList.remove('ql-cell-selected-after');
      });
      
      // Add focus class ONLY to clicked cell
      cell.classList.add('ql-cell-focused');
      console.log('Cell focused:', cell);
      
      // Mark that we're in a table cell
      isInTableCell = true;
      
      // Ensure cursor positioning inside cell after Quill processes the click
      setTimeout(() => {
        const cellBlot = Quill.find(cell);
        if (cellBlot) {
          const cellIndex = snow.getIndex(cellBlot);
          // Set cursor to beginning of cell content
          snow.setSelection(cellIndex, 0);
        }
        // Ensure focus for keyboard
        editor.focus();
        snow.focus();
      }, 50); // Increased delay to ensure Quill has processed the click
    }
    // Call the original handler
    updateToolbarFromCell(e);
  }, { capture: true });
  
  // Stop marking as in table cell when clicking outside
  document.addEventListener('click', function(e) {
    if (!e.target.closest('td')) {
      isInTableCell = false;
      // Remove focus and selection classes from ALL cells when clicking outside
      document.querySelectorAll('td').forEach(c => {
        c.classList.remove('ql-cell-focused');
        c.classList.remove('ql-cell-selected');
        c.classList.remove('ql-cell-selected-after');
      });
    }
  }, { capture: true });
  
  // Prevent document blur when in table cell
  document.addEventListener('blur', function(e) {
    if (isInTableCell && (e.target === editor || e.target === snow.root)) {
      console.log('Prevented document blur while in table cell');
      e.preventDefault();
      e.stopPropagation();
      editor.focus();
      snow.focus();
    }
  }, { capture: true });
  
  editor.addEventListener('touchend', function(e) {
    const cell = e.target.closest('td');
    if (cell) {
      // Don't stop propagation - let normal touch handling occur
      
      // Remove focus and conflicting selection classes from ALL cells
      document.querySelectorAll('td').forEach(c => {
        c.classList.remove('ql-cell-focused');
        c.classList.remove('ql-cell-selected');
        c.classList.remove('ql-cell-selected-after');
      });
      
      // Add focus class ONLY to clicked cell
      cell.classList.add('ql-cell-focused');
      console.log('Cell focused (touchend):', cell);
      
      // Mark that we're in a table cell
      isInTableCell = true;
      
      // Ensure cursor positioning inside cell after Quill processes the touch
      setTimeout(() => {
        const cellBlot = Quill.find(cell);
        if (cellBlot) {
          const cellIndex = snow.getIndex(cellBlot);
          // Set cursor to beginning of cell content
          snow.setSelection(cellIndex, 0);
        }
        // Ensure focus for keyboard
        editor.focus();
        snow.focus();
      }, 50); // Increased delay to ensure Quill has processed the touch
    }
    // Call the original handler
    updateToolbarFromCell(e);
  }, { capture: true });

  // All cell handling is done in the main event listeners above


  (function () {
    try {
      // Clear interval timers
      if (window.tessellationTimer) clearInterval(window.tessellationTimer);
      if (window.tessellationPollingTimer) clearInterval(window.tessellationPollingTimer);

      // Clean up event listeners - use this method to get around scope issues
      const handlers = [
        "updateToolbarFromCell", "cellClickHandler", "handleCellInteraction",
        "handleCellClick", "tessellationCellHandler", "onCellClick",
        "mobileHandler", "globalClickHandler", "handleCellSelect"
      ];

      handlers.forEach(function (handlerName) {
        try {
          const handler = window[handlerName];
          if (typeof handler === 'function') {
            document.removeEventListener('click', handler, true);
            document.removeEventListener('touchstart', handler, true);
            document.removeEventListener('mousedown', handler, true);
            editor.removeEventListener('click', handler, true);
            editor.removeEventListener('touchstart', handler, true);
            editor.removeEventListener('mousedown', handler, true);
          }
        } catch (e) { /* ignore */ }
      });

      console.log("All previous code cleaned up");
    } catch (e) {
      console.log("Error during cleanup:", e);
    }

    // EXTREMELY SIMPLE APPROACH

    // Track if user has manually deselected formats
    const userDeselectedFormats = {
      bold: false,
      italic: false,
      underline: false,
      strike: false
    };

  // All cell handling is done in the main click/touchend handlers above

    // Prevent native context menu on table cells (only on long-press)
    let touchTimer;
    document.getElementById('editor').addEventListener('touchstart', function(e) {
      const cell = e.target.closest('td, th');
      if (cell) {
        // Set a timer for long-press detection
        touchTimer = setTimeout(function() {
          // This is a long-press, prevent the context menu
          e.preventDefault();
          const selection = window.getSelection();
          if (selection) {
            selection.removeAllRanges();
          }
        }, 500); // 500ms for long-press
      }
    }, { passive: false });

    document.getElementById('editor').addEventListener('touchend', function(e) {
      // Clear the timer if touch ends before long-press
      if (touchTimer) {
        clearTimeout(touchTimer);
      }
    });

    document.getElementById('editor').addEventListener('touchmove', function(e) {
      // Clear the timer if user is scrolling
      if (touchTimer) {
        clearTimeout(touchTimer);
      }
    });

    // Handle text changes
    snow.on('text-change', function (delta, oldDelta, source) {
      // Only process user-initiated changes
      if (source !== 'user') return;

      // Check if we're adding text (typing)
      if (delta.ops && delta.ops.some(op => op.insert)) {
        const range = snow.getSelection();
        if (!range) return;

        // Handle deselected formats only for the newly inserted text
        Object.keys(userDeselectedFormats).forEach(format => {
          if (userDeselectedFormats[format]) {
            console.log(`Applying ${format} format removal to new text only`);

            // Only apply to the current cursor position/selection
            // This ensures we don't affect previously formatted text
            snow.format(format, false);
          }
        });
      }

      // Send content to native app (preserve this functionality)
      sendContentToNativeApp();

    });
    
  })();


  // Add keyboard detection for iOS with fixed height
  let currentKeyboardHeight = 0;
  let isKeyboardVisible = false;
  let lastKnownKeyboardHeight = 390; // Fixed iOS keyboard height
  let scrollInProgress = false;

  // Function to adjust scroll for a given selection index
  function adjustScrollForSelection(index, editorContainer, quill) {
    // Set flag to prevent multiple scroll operations
    scrollInProgress = true;

    // Get bounds for the current selection
    const bounds = quill.getBounds(index);

    // Calculate viewport and cursor positions
    const viewportHeight = editorContainer.clientHeight;
    const cursorPosition = bounds.top;
    const lineHeight = bounds.height || 20;

    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // Always use the fixed keyboard height on iOS
    const effectiveKeyboardHeight = isIOS ? lastKnownKeyboardHeight : 0;

    // Calculate adjusted viewport height based on keyboard
    const adjustedViewportHeight = isIOS ?
      viewportHeight - (effectiveKeyboardHeight * 0.8) : viewportHeight;

    // iOS-specific offset to position text higher (increased for better visibility)
    const iosOffset = isIOS ? 100 : 0;

    // Calculate target scroll position
    const targetScrollTop = cursorPosition - (adjustedViewportHeight / 2) + (lineHeight / 2) + iosOffset;

    console.log('Scroll calculation:', {
      viewportHeight,
      adjustedViewportHeight,
      cursorPosition,
      lineHeight,
      iosOffset,
      targetScrollTop,
      keyboardHeight: effectiveKeyboardHeight
    });

    // Multi-step scroll approach for iOS
    if (isIOS) {
      // Step 1: Initial scroll with animation frame for better timing
      requestAnimationFrame(() => {
        editorContainer.scrollTop = Math.max(0, targetScrollTop);

        // Step 2: Verify scroll position after a delay
        setTimeout(() => {
          const currentPosition = editorContainer.scrollTop;
          const expectedPosition = Math.max(0, targetScrollTop);

          console.log('Scroll verification:', {
            current: currentPosition,
            expected: expectedPosition
          });

          if (Math.abs(currentPosition - expectedPosition) > 10) {
            // Step 3: If verification fails, try alternative approach
            console.log('Using fallback scroll method');

            // Try scrollIntoView as fallback
            const selection = quill.getSelection();
            if (selection) {
              console.log(selection);
              const [leaf] = quill.getLeaf(selection.index);
              console.log("leaf", leaf);
              console.log("leaf", leaf?.domNode);

              // Find a valid DOM element to scroll to
              let scrollElement = null;

              // Check if leaf.domNode exists and is a valid element
              if (leaf && leaf.domNode) {
                // Try to find the closest element that supports scrollIntoView
                if (leaf.domNode.nodeType === 1 && typeof leaf.domNode.scrollIntoView === 'function') {
                  // If it's an element node with scrollIntoView
                  scrollElement = leaf.domNode;
                } else if (leaf.domNode.parentElement) {
                  // Try parent element if available
                  scrollElement = leaf.domNode.parentElement;
                }
              }

              // If we found a valid element to scroll to
              if (scrollElement) {
                try {
                  scrollElement.scrollIntoView({
                    block: 'center',
                    behavior: 'auto'
                  });

                  // Additional manual adjustment after scrollIntoView
                  setTimeout(() => {
                    // Apply additional offset to move text higher above keyboard
                    // Use a smaller offset to prevent overshooting
                    editorContainer.scrollTop = editorContainer.scrollTop - 60;
                    scrollInProgress = false;
                  }, 50);
                } catch (e) {
                  console.log('ScrollIntoView failed:', e);
                  // Last resort: direct scroll
                  editorContainer.scrollTop = expectedPosition;
                  scrollInProgress = false;
                }
              } else {
                // If we couldn't find a valid element, fall back to direct scrolling
                console.log('No valid scroll element found, using direct scroll');
                editorContainer.scrollTop = expectedPosition;
                scrollInProgress = false;
              }
            } else {
              editorContainer.scrollTop = expectedPosition;
              scrollInProgress = false;
            }
          } else {
            // Scroll position is correct
            scrollInProgress = false;
          }

          // Ensure the editor is focused
          if (!window.isSearchPanelOpen) {
            quill.focus();
          }
        }, 100);
      });
    } else {
      // For non-iOS, simple direct scroll
      editorContainer.scrollTop = Math.max(0, targetScrollTop);
      scrollInProgress = false;
      // Ensure the editor is focused
      if (!window.isSearchPanelOpen) {
        snow.focus();
      }
    }
  }

   // Standalone search function with arrow key navigation
    class EditorSearch {
      constructor() {
        this.quill = snow; // Reference to your Quill instance
        this.matches = [];
        this.currentIndex = -1;
        this.highlightElements = [];
        this.isActive = false;
        this.searchTerm = '';
        
        // Set up keyboard listener for navigation
        this.setupKeyboardNavigation();

         // Set up listeners to clear highlights when user interacts with editor
        this.setupEditorInteractionListeners();
      }
      
      /**
       * Main search function - call this to search for a term
       * @param {string} searchTerm - The text to search for
       * @returns {object} - Search results with match count and current position
       */
      searchAndHighlight(searchTerm) {
        console.log('[EditorSearch] Searching for:', searchTerm);
        
        // Clear previous search
        this.clearSearch();
        
        if (!searchTerm || searchTerm.trim() === '') {
          console.warn('[EditorSearch] Empty search term');
          return { matches: 0, currentIndex: -1 };
        }
        
        this.searchTerm = searchTerm;
        this.isActive = true;
        
        // Get all text from editor
        const text = this.quill.getText();
        
        // Escape special regex characters and create case-insensitive regex
        const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(escapedTerm, 'gi');
        
        let match;
        
        // Find all matches
        while ((match = regex.exec(text)) !== null) {
          this.matches.push({
            index: match.index,
            length: searchTerm.length,
            text: match[0]
          });
        }
        
        console.log('[EditorSearch] Found matches:', this.matches.length);
        
        if (this.matches.length > 0) {
          // Go to first match
          this.currentIndex = 0;
          this.highlightAllMatches();
          this.scrollToCurrentMatch();
          
          return {
            matches: this.matches.length,
            currentIndex: this.currentIndex + 1,
            total: this.matches.length
          };
        } else {
          this.isActive = false;
          return { matches: 0, currentIndex: -1 };
        }
      }
      
      /**
       * Highlight all matches in the editor
       */
     highlightAllMatches() {
        // Clear previous highlights
        this.clearHighlights();
        
        this.matches.forEach((match, idx) => {
          const isActive = idx === this.currentIndex;
          
          try {
            // Use Quill's formatText to apply background color
            this.quill.formatText(
              match.index,
              match.length,
              'background',
              isActive ? '#FFA500' : '#FFEB3B', // Orange for active, yellow for others
              'silent'
            );
            
            // Store match info for clearing later
            this.highlightElements.push({
              index: match.index,
              length: match.length
            });
          } catch (e) {
            console.warn('[EditorSearch] Error highlighting match at index', match.index, e);
          }
        });
        
        console.log('[EditorSearch] Highlighted', this.highlightElements.length, 'matches');
      }
      
      /**
       * Scroll to the current match
       */
      scrollToCurrentMatch() {
        if (this.currentIndex < 0 || this.currentIndex >= this.matches.length) {
          return;
        }
        
        const match = this.matches[this.currentIndex];
        
        try {
          // Set selection to the match
          this.quill.setSelection(match.index, match.length, 'user');
          
          // Get bounds for scrolling
          const bounds = this.quill.getBounds(match.index, match.length);
          
          if (bounds) {
            const editor = document.getElementById('editor');
            const editorRect = editor.getBoundingClientRect();
            
            // Calculate if we need to scroll
            const matchTop = bounds.top;
            const matchBottom = bounds.top + bounds.height;
            const viewportTop = editor.scrollTop;
            const viewportBottom = viewportTop + editorRect.height;
            
            // Scroll if match is not fully visible
            if (matchTop < viewportTop || matchBottom > viewportBottom) {
              // Center the match in the viewport
              const scrollTo = editor.scrollTop + matchTop - (editorRect.height / 2);
              editor.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
              });
            }
          }
          
          console.log('[EditorSearch] Scrolled to match', this.currentIndex + 1, 'of', this.matches.length);
        } catch (e) {
          console.error('[EditorSearch] Error scrolling to match:', e);
        }
      }
      
      /**
       * Navigate to next match
       */
      goToNextMatch() {
        if (this.matches.length === 0 || !this.isActive) {
          console.warn('[EditorSearch] No active search');
          return null;
        }
        
        this.currentIndex = (this.currentIndex + 1) % this.matches.length;
        this.highlightAllMatches();
        this.scrollToCurrentMatch();
        
        console.log('[EditorSearch] Moved to match', this.currentIndex + 1, 'of', this.matches.length);
        
        return {
          currentIndex: this.currentIndex + 1,
          total: this.matches.length
        };
      }
      
      /**
       * Navigate to previous match
       */
      goToPreviousMatch() {
        if (this.matches.length === 0 || !this.isActive) {
          console.warn('[EditorSearch] No active search');
          return null;
        }
        
        this.currentIndex = this.currentIndex - 1;
        if (this.currentIndex < 0) {
          this.currentIndex = this.matches.length - 1;
        }
        
        this.highlightAllMatches();
        this.scrollToCurrentMatch();
        
        console.log('[EditorSearch] Moved to match', this.currentIndex + 1, 'of', this.matches.length);
        
        return {
          currentIndex: this.currentIndex + 1,
          total: this.matches.length
        };
      }
      
      /**
       * Clear all highlights
       */
     clearHighlights() {
      this.highlightElements.forEach(match => {
        try {
          // Remove background formatting from Quill
          this.quill.formatText(match.index, match.length, 'background', false, 'silent');
        } catch (e) {
          console.warn('[EditorSearch] Error clearing highlight:', e);
        }
      });
      this.highlightElements = [];
    }
      
      /**
       * Clear the entire search
       */
      clearSearch() {
        this.clearHighlights();
        this.matches = [];
        this.currentIndex = -1;
        this.isActive = false;
        this.searchTerm = '';
        console.log('[EditorSearch] Search cleared');
      }
      
      /**
       * Set up keyboard navigation (down arrow for next, up arrow for previous)
       */
      setupKeyboardNavigation() {
        document.addEventListener('keydown', (e) => {
          // Only handle if search is active
          if (!this.isActive || this.matches.length === 0) {
            return;
          }
          
          // Check if we're not in an input field
          const activeElement = document.activeElement;
          const isInInput = activeElement && (
            activeElement.tagName === 'INPUT' ||
            activeElement.tagName === 'TEXTAREA'
          );
          
          // Down arrow - go to next match
          if (e.key === 'ArrowDown' && !isInInput) {
            e.preventDefault();
            this.goToNextMatch();
          }
          
          // Up arrow - go to previous match
          if (e.key === 'ArrowUp' && !isInInput) {
            e.preventDefault();
            this.goToPreviousMatch();
          }
          
          // Escape - clear search
          if (e.key === 'Escape') {
            this.clearSearch();
          }
        });
      }
      
     
     /**
   * Set up listeners to clear search when user interacts with editor
   */
      setupEditorInteractionListeners() {
        // Clear highlights when user clicks in the editor
        this.quill.root.addEventListener('click', () => {
          if (this.isActive) {
            console.log('[EditorSearch] User clicked in editor - clearing search');
            this.clearSearch();
          }
        });
        
        // Clear highlights when user starts typing
        this.quill.on('text-change', (delta, oldDelta, source) => {
          // Only clear if the change was made by the user (not programmatically)
          if (source === 'user' && this.isActive) {
            console.log('[EditorSearch] User typed in editor - clearing search');
            this.clearSearch();
          }
        });
        
        // Clear highlights when selection changes (user moves cursor)
        // this.quill.on('selection-change', (range, oldRange, source) => {
        //   // Only clear if user manually changed selection and search is active
        //   if (source === 'user' && this.isActive && range) {
        //     // Check if the selection change was not caused by our search navigation
        //     const isSearchNavigation = this.matches.some(match => 
        //       range.index === match.index && range.length === match.length
        //     );
            
        //     if (!isSearchNavigation) {
        //       console.log('[EditorSearch] User changed selection - clearing search');
        //       this.clearSearch();
        //     }
        //   }
        // });
      }
  
      /**
       * Get current search status
       */
      getStatus() {
        return {
          isActive: this.isActive,
          searchTerm: this.searchTerm,
          totalMatches: this.matches.length,
          currentMatch: this.currentIndex + 1
        };
      }
    }

   // Create global instance
    window.editorSearch = new EditorSearch();
    /**
     * Convenience function to search - you can call this from anywhere
     * @param {string} searchTerm - The text to search for
     * @returns {object} - Search results
     */
    function searchInEditor(searchTerm) {
      return window.editorSearch.searchAndHighlight(searchTerm);
    }
    /**
     * Navigate to next match
     */
    function searchNext() {
      return window.editorSearch.goToNextMatch();
    }
    /**
     * Navigate to previous match
     */
    function searchPrevious() {
      return window.editorSearch.goToPreviousMatch();
    }
    /**
     * Clear current search
     */
    function clearSearch() {
      window.editorSearch.clearSearch();
    }

</script>
